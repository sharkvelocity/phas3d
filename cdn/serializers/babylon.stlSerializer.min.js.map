{"version":3,"file":"babylon.stlSerializer.min.js","mappings":"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","sources":["webpack://SERIALIZERS/webpack/universalModuleDefinition","webpack://SERIALIZERS/external umd {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}","webpack://SERIALIZERS/webpack/bootstrap","webpack://SERIALIZERS/webpack/runtime/define property getters","webpack://SERIALIZERS/webpack/runtime/global","webpack://SERIALIZERS/webpack/runtime/hasOwnProperty shorthand","webpack://SERIALIZERS/webpack/runtime/make namespace object","webpack://SERIALIZERS/../../../dev/serializers/src/stl/stlSerializer.ts","webpack://SERIALIZERS/../../../lts/serializers/src/legacy/legacy-stlSerializer.ts","webpack://SERIALIZERS/./src/stl.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-serializers\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-serializers\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"SERIALIZERS\"] = factory(root[\"BABYLON\"]);\n})((typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : this), (__WEBPACK_EXTERNAL_MODULE__597__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__597__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Mesh } from \"core/Meshes/mesh\";\r\nimport { InstancedMesh } from \"core/Meshes/instancedMesh\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\n\r\n/**\r\n * Class for generating STL data from a Babylon scene.\r\n */\r\nexport class STLExport {\r\n    /**\r\n     * Exports the geometry of a Mesh array in .STL file format (ASCII)\r\n     * @param meshes list defines the mesh to serialize\r\n     * @param download triggers the automatic download of the file.\r\n     * @param fileName changes the downloads fileName.\r\n     * @param binary changes the STL to a binary type.\r\n     * @param isLittleEndian toggle for binary type exporter.\r\n     * @param doNotBakeTransform toggle if meshes transforms should be baked or not.\r\n     * @param supportInstancedMeshes toggle to export instanced Meshes. Enabling support for instanced meshes will override doNoBakeTransform as true\r\n     * @param exportIndividualMeshes toggle to export each mesh as an independent mesh. By default, all the meshes are combined into one mesh. This property has no effect when exporting in binary format\r\n     * @returns the STL as UTF8 string\r\n     */\r\n    public static CreateSTL(\r\n        meshes: (Mesh | InstancedMesh)[],\r\n        download: boolean = true,\r\n        fileName: string = \"stlmesh\",\r\n        binary: boolean = false,\r\n        isLittleEndian: boolean = true,\r\n        doNotBakeTransform: boolean = false,\r\n        supportInstancedMeshes: boolean = false,\r\n        exportIndividualMeshes: boolean = false\r\n    ): any {\r\n        //Binary support adapted from https://gist.github.com/paulkaplan/6d5f0ab2c7e8fdc68a61\r\n\r\n        const getFaceData = function (indices: any, vertices: any, i: number) {\r\n            const id = [indices[i] * 3, indices[i + 1] * 3, indices[i + 2] * 3];\r\n            const v = [\r\n                new Vector3(vertices[id[0]], vertices[id[0] + 2], vertices[id[0] + 1]),\r\n                new Vector3(vertices[id[1]], vertices[id[1] + 2], vertices[id[1] + 1]),\r\n                new Vector3(vertices[id[2]], vertices[id[2] + 2], vertices[id[2] + 1]),\r\n            ];\r\n            const p1p2 = v[0].subtract(v[1]);\r\n            const p3p2 = v[2].subtract(v[1]);\r\n            const n = Vector3.Cross(p3p2, p1p2).normalize();\r\n\r\n            return { v, n };\r\n        };\r\n\r\n        const writeVector = function (dataview: any, offset: number, vector: Vector3, isLittleEndian: boolean) {\r\n            offset = writeFloat(dataview, offset, vector.x, isLittleEndian);\r\n            offset = writeFloat(dataview, offset, vector.y, isLittleEndian);\r\n            return writeFloat(dataview, offset, vector.z, isLittleEndian);\r\n        };\r\n\r\n        const writeFloat = function (dataview: any, offset: number, value: number, isLittleEndian: boolean) {\r\n            dataview.setFloat32(offset, value, isLittleEndian);\r\n            return offset + 4;\r\n        };\r\n\r\n        const getVerticesData = function (mesh: InstancedMesh | Mesh) {\r\n            if (supportInstancedMeshes) {\r\n                let sourceMesh = mesh;\r\n                if (mesh instanceof InstancedMesh) {\r\n                    sourceMesh = mesh.sourceMesh;\r\n                }\r\n                const data = sourceMesh.getVerticesData(VertexBuffer.PositionKind, true, true);\r\n                if (!data) {\r\n                    return [];\r\n                }\r\n                const temp = Vector3.Zero();\r\n                let index;\r\n                for (index = 0; index < data.length; index += 3) {\r\n                    Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], mesh.computeWorldMatrix(true), temp).toArray(data, index);\r\n                }\r\n                return data;\r\n            } else {\r\n                return mesh.getVerticesData(VertexBuffer.PositionKind) || [];\r\n            }\r\n        };\r\n\r\n        if (supportInstancedMeshes) {\r\n            doNotBakeTransform = true;\r\n        }\r\n\r\n        let data: DataView | string = \"\";\r\n\r\n        let faceCount = 0;\r\n        let offset = 0;\r\n\r\n        if (binary) {\r\n            for (let i = 0; i < meshes.length; i++) {\r\n                const mesh = meshes[i];\r\n                const indices = mesh.getIndices();\r\n                faceCount += indices ? indices.length / 3 : 0;\r\n            }\r\n\r\n            const bufferSize = 84 + 50 * faceCount;\r\n            const buffer = new ArrayBuffer(bufferSize);\r\n            data = new DataView(buffer);\r\n\r\n            offset += 80;\r\n            data.setUint32(offset, faceCount, isLittleEndian);\r\n            offset += 4;\r\n        } else {\r\n            if (!exportIndividualMeshes) {\r\n                data = \"solid stlmesh\\r\\n\";\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const mesh = meshes[i];\r\n            if (!binary && exportIndividualMeshes) {\r\n                data += \"solid \" + mesh.name + \"\\r\\n\";\r\n            }\r\n            if (!doNotBakeTransform && mesh instanceof Mesh) {\r\n                mesh.bakeCurrentTransformIntoVertices();\r\n            }\r\n            const vertices = getVerticesData(mesh);\r\n            const indices = mesh.getIndices() || [];\r\n\r\n            for (let i = 0; i < indices.length; i += 3) {\r\n                const fd = getFaceData(indices, vertices, i);\r\n\r\n                if (binary) {\r\n                    offset = writeVector(data, offset, fd.n, isLittleEndian);\r\n                    offset = writeVector(data, offset, fd.v[0], isLittleEndian);\r\n                    offset = writeVector(data, offset, fd.v[1], isLittleEndian);\r\n                    offset = writeVector(data, offset, fd.v[2], isLittleEndian);\r\n                    offset += 2;\r\n                } else {\r\n                    data += \"\\tfacet normal \" + fd.n.x + \" \" + fd.n.y + \" \" + fd.n.z + \"\\r\\n\";\r\n                    data += \"\\t\\touter loop\\r\\n\";\r\n                    data += \"\\t\\t\\tvertex \" + fd.v[0].x + \" \" + fd.v[0].y + \" \" + fd.v[0].z + \"\\r\\n\";\r\n                    data += \"\\t\\t\\tvertex \" + fd.v[1].x + \" \" + fd.v[1].y + \" \" + fd.v[1].z + \"\\r\\n\";\r\n                    data += \"\\t\\t\\tvertex \" + fd.v[2].x + \" \" + fd.v[2].y + \" \" + fd.v[2].z + \"\\r\\n\";\r\n                    data += \"\\t\\tendloop\\r\\n\";\r\n                    data += \"\\tendfacet\\r\\n\";\r\n                }\r\n            }\r\n            if (!binary && exportIndividualMeshes) {\r\n                data += \"endsolid \" + name + \"\\r\\n\";\r\n            }\r\n        }\r\n\r\n        if (!binary && !exportIndividualMeshes) {\r\n            data += \"endsolid stlmesh\";\r\n        }\r\n\r\n        if (download) {\r\n            const a = document.createElement(\"a\");\r\n            const blob = new Blob([data], { type: \"application/octet-stream\" });\r\n            a.href = window.URL.createObjectURL(blob);\r\n            a.download = fileName + \".stl\";\r\n            a.click();\r\n        }\r\n\r\n        return data;\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/no-restricted-imports */\r\nimport * as Serializers from \"serializers/stl/index\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nconst globalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof globalObject !== \"undefined\") {\r\n    for (const serializer in Serializers) {\r\n        (<any>globalObject).BABYLON[serializer] = (<any>Serializers)[serializer];\r\n    }\r\n}\r\n\r\nexport * from \"serializers/stl/index\";\r\n","import * as serializers from \"@lts/serializers/legacy/legacy-stlSerializer\";\r\nexport { serializers };\r\nexport default serializers;\r\n"],"names":["root","factory","exports","module","require","define","amd","self","global","this","__WEBPACK_EXTERNAL_MODULE__597__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","Function","e","window","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","CreateSTL","meshes","download","fileName","binary","isLittleEndian","doNotBakeTransform","supportInstancedMeshes","exportIndividualMeshes","getFaceData","indices","vertices","i","id","v","Vector3","p1p2","subtract","p3p2","n","Cross","normalize","writeVector","dataview","offset","vector","writeFloat","x","y","z","setFloat32","getVerticesData","mesh","sourceMesh","InstancedMesh","VertexBuffer","PositionKind","temp","Zero","index","length","TransformCoordinatesFromFloatsToRef","computeWorldMatrix","toArray","data","faceCount","getIndices","buffer","ArrayBuffer","DataView","setUint32","name","Mesh","bakeCurrentTransformIntoVertices","fd","a","document","createElement","blob","Blob","type","href","URL","createObjectURL","click","globalObject","serializer","BABYLON"],"sourceRoot":""}
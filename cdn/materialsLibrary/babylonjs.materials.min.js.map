{"version":3,"file":"babylonjs.materials.min.js","mappings":"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","sources":["webpack://MATERIALS/webpack/universalModuleDefinition","webpack://MATERIALS/external umd {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}","webpack://MATERIALS/webpack/bootstrap","webpack://MATERIALS/webpack/runtime/define property getters","webpack://MATERIALS/webpack/runtime/global","webpack://MATERIALS/webpack/runtime/hasOwnProperty shorthand","webpack://MATERIALS/webpack/runtime/make namespace object","webpack://MATERIALS/../../../../node_modules/tslib/tslib.es6.mjs","webpack://MATERIALS/../../../dev/materials/src/cell/cell.fragment.ts","webpack://MATERIALS/../../../dev/materials/src/cell/cell.vertex.ts","webpack://MATERIALS/../../../dev/materials/src/cell/cellMaterial.ts","webpack://MATERIALS/../../../dev/materials/src/custom/customMaterial.ts","webpack://MATERIALS/../../../dev/materials/src/custom/pbrCustomMaterial.ts","webpack://MATERIALS/../../../dev/materials/src/fire/fire.fragment.ts","webpack://MATERIALS/../../../dev/materials/src/fire/fire.vertex.ts","webpack://MATERIALS/../../../dev/materials/src/fire/fireMaterial.ts","webpack://MATERIALS/../../../dev/materials/src/fur/fur.fragment.ts","webpack://MATERIALS/../../../dev/materials/src/fur/fur.vertex.ts","webpack://MATERIALS/../../../dev/materials/src/fur/furMaterial.ts","webpack://MATERIALS/../../../dev/materials/src/gradient/gradient.fragment.ts","webpack://MATERIALS/../../../dev/materials/src/gradient/gradient.vertex.ts","webpack://MATERIALS/../../../dev/materials/src/gradient/gradientMaterial.ts","webpack://MATERIALS/../../../dev/materials/src/grid/grid.fragment.ts","webpack://MATERIALS/../../../dev/materials/src/grid/grid.vertex.ts","webpack://MATERIALS/../../../dev/materials/src/grid/gridMaterial.ts","webpack://MATERIALS/../../../dev/materials/src/lava/lava.fragment.ts","webpack://MATERIALS/../../../dev/materials/src/lava/lava.vertex.ts","webpack://MATERIALS/../../../dev/materials/src/lava/lavaMaterial.ts","webpack://MATERIALS/../../../dev/materials/src/mix/mix.fragment.ts","webpack://MATERIALS/../../../dev/materials/src/mix/mix.vertex.ts","webpack://MATERIALS/../../../dev/materials/src/mix/mixMaterial.ts","webpack://MATERIALS/../../../dev/materials/src/normal/normal.fragment.ts","webpack://MATERIALS/../../../dev/materials/src/normal/normal.vertex.ts","webpack://MATERIALS/../../../dev/materials/src/normal/normalMaterial.ts","webpack://MATERIALS/../../../dev/materials/src/shadowOnly/shadowOnly.fragment.ts","webpack://MATERIALS/../../../dev/materials/src/shadowOnly/shadowOnly.vertex.ts","webpack://MATERIALS/../../../dev/materials/src/shadowOnly/shadowOnlyMaterial.ts","webpack://MATERIALS/../../../dev/materials/src/simple/simple.fragment.ts","webpack://MATERIALS/../../../dev/materials/src/simple/simple.vertex.ts","webpack://MATERIALS/../../../dev/materials/src/simple/simpleMaterial.ts","webpack://MATERIALS/../../../dev/materials/src/sky/sky.fragment.ts","webpack://MATERIALS/../../../dev/materials/src/sky/sky.vertex.ts","webpack://MATERIALS/../../../dev/materials/src/sky/skyMaterial.ts","webpack://MATERIALS/../../../dev/materials/src/terrain/terrain.fragment.ts","webpack://MATERIALS/../../../dev/materials/src/terrain/terrain.vertex.ts","webpack://MATERIALS/../../../dev/materials/src/terrain/terrainMaterial.ts","webpack://MATERIALS/../../../dev/materials/src/triPlanar/triplanar.fragment.ts","webpack://MATERIALS/../../../dev/materials/src/triPlanar/triplanar.vertex.ts","webpack://MATERIALS/../../../dev/materials/src/triPlanar/triPlanarMaterial.ts","webpack://MATERIALS/../../../dev/materials/src/water/water.fragment.ts","webpack://MATERIALS/../../../dev/materials/src/water/water.vertex.ts","webpack://MATERIALS/../../../dev/materials/src/water/waterMaterial.ts","webpack://MATERIALS/../../../lts/materials/src/legacy/legacy.ts","webpack://MATERIALS/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-materials\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-materials\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"MATERIALS\"] = factory(root[\"BABYLON\"]);\n})((typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : this), (__WEBPACK_EXTERNAL_MODULE__597__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__597__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"cellPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;varying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvec3 computeCustomDiffuseLighting(lightingInfo info,vec3 diffuseBase,float shadow)\n{diffuseBase=info.diffuse*shadow;\n#ifdef CELLBASIC\nfloat level=1.0;if (info.ndl<0.5)\nlevel=0.5;diffuseBase.rgb*vec3(level,level,level);\n#else\nfloat ToonThresholds[4];ToonThresholds[0]=0.95;ToonThresholds[1]=0.5;ToonThresholds[2]=0.2;ToonThresholds[3]=0.03;float ToonBrightnessLevels[5];ToonBrightnessLevels[0]=1.0;ToonBrightnessLevels[1]=0.8;ToonBrightnessLevels[2]=0.6;ToonBrightnessLevels[3]=0.35;ToonBrightnessLevels[4]=0.2;if (info.ndl>ToonThresholds[0])\n{diffuseBase.rgb*=ToonBrightnessLevels[0];}\nelse if (info.ndl>ToonThresholds[1])\n{diffuseBase.rgb*=ToonBrightnessLevels[1];}\nelse if (info.ndl>ToonThresholds[2])\n{diffuseBase.rgb*=ToonBrightnessLevels[2];}\nelse if (info.ndl>ToonThresholds[3])\n{diffuseBase.rgb*=ToonBrightnessLevels[3];}\nelse\n{diffuseBase.rgb*=ToonBrightnessLevels[4];}\n#endif\nreturn max(diffuseBase,vec3(0.2));}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV);\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\nlightingInfo info;vec3 diffuseBase=vec3(0.,0.,0.);float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif \n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;vec4 color=vec4(finalDiffuse,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const cellPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\n\nconst name = \"cellVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#ifdef VERTEXCOLOR\nvec4 colorUpdated=color;\n#endif\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x==0.)\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}\nelse\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const cellVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\n\r\nimport \"./cell.fragment\";\r\nimport \"./cell.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass CellMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public NDOTL = true;\r\n    public CUSTOMUSERLIGHTING = true;\r\n    public CELLBASIC = true;\r\n    public DEPTHPREPASS = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public AREALIGHTSUPPORTED = true;\r\n    public AREALIGHTNOROUGHTNESS = true;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class CellMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsColor3(\"diffuse\")\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize(\"computeHighLevel\")\r\n    public _computeHighLevel: boolean = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public computeHighLevel: boolean;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public override needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public override needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public override getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new CellMaterialDefines();\r\n        }\r\n\r\n        const defines = <CellMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // High level\r\n        defines.CELLBASIC = !this.computeHighLevel;\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const shaderName = \"cell\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n                \"logarithmicDepthConstant\",\r\n            ];\r\n            const samplers = [\"diffuseSampler\", \"areaLightsLTC1Sampler\", \"areaLightsLTC2Sampler\"];\r\n            const uniformBuffers: string[] = [];\r\n\r\n            AddClipPlaneUniforms(uniforms);\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights - 1 },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n\r\n        // Check if Area Lights have LTC texture.\r\n        if (defines[\"AREALIGHTUSED\"]) {\r\n            for (let index = 0; index < mesh.lightSources.length; index++) {\r\n                if (!mesh.lightSources[index]._isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <CellMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this._diffuseTexture.getTextureMatrix());\r\n            }\r\n\r\n            // Clip plane\r\n            BindClipPlane(this._activeEffect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        // Lights\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public override getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\r\n            results.push(this._diffuseTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public override getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        return this._diffuseTexture === texture;\r\n    }\r\n\r\n    public override dispose(forceDisposeEffect?: boolean): void {\r\n        if (this._diffuseTexture) {\r\n            this._diffuseTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"CellMaterial\";\r\n    }\r\n\r\n    public override clone(name: string): CellMaterial {\r\n        return SerializationHelper.Clone<CellMaterial>(() => new CellMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.CellMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): CellMaterial {\r\n        return SerializationHelper.Parse(() => new CellMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CellMaterial\", CellMaterial);\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport type { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { Color3, Color4 } from \"core/Maths/math.color\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\n\r\nimport \"core/Shaders/default.vertex\";\r\nimport \"core/Shaders/default.fragment\";\r\n\r\n/**\r\n * Structure of a custom shader\r\n */\r\nexport class CustomShaderStructure {\r\n    /**\r\n     * Fragment store\r\n     */\r\n    public FragmentStore: string;\r\n    /**\r\n     * Vertex store\r\n     */\r\n    public VertexStore: string;\r\n\r\n    constructor() {}\r\n}\r\n\r\n/**\r\n * Parts of a shader\r\n */\r\nexport class ShaderSpecialParts {\r\n    constructor() {}\r\n\r\n    /**\r\n     * Beginning of the fragment shader\r\n     */\r\n    public Fragment_Begin: string;\r\n    /**\r\n     * Variable definitions of the fragment shader\r\n     */\r\n    public Fragment_Definitions: string;\r\n    /**\r\n     * Beginning of the fragment main function\r\n     */\r\n    public Fragment_MainBegin: string;\r\n    /**\r\n     * End of the fragment main function\r\n     */\r\n    public Fragment_MainEnd: string;\r\n\r\n    /**\r\n     * Diffuse color calculation\r\n     */\r\n    public Fragment_Custom_Diffuse: string;\r\n    /**\r\n     * Before lightning computations\r\n     */\r\n    public Fragment_Before_Lights: string;\r\n    /**\r\n     * Before fog computations\r\n     */\r\n    public Fragment_Before_Fog: string;\r\n    /**\r\n     * Alpha calculations\r\n     */\r\n    public Fragment_Custom_Alpha: string;\r\n    /**\r\n     * Before frag color is assigned\r\n     */\r\n    public Fragment_Before_FragColor: string;\r\n    /**\r\n     * Beginning of the vertex shader\r\n     */\r\n    public Vertex_Begin: string;\r\n    /**\r\n     * Variable definitions of the vertex shader\r\n     */\r\n    public Vertex_Definitions: string;\r\n    /**\r\n     * Start of the main function of the vertex shader\r\n     */\r\n    public Vertex_MainBegin: string;\r\n\r\n    /**\r\n     * Before the world position computation\r\n     */\r\n    public Vertex_Before_PositionUpdated: string;\r\n\r\n    /**\r\n     * Before the normal computation\r\n     */\r\n    public Vertex_Before_NormalUpdated: string;\r\n\r\n    /**\r\n     * After the world position has been computed\r\n     */\r\n    public Vertex_After_WorldPosComputed: string;\r\n\r\n    /**\r\n     * Main end of the vertex shader\r\n     */\r\n    public Vertex_MainEnd: string;\r\n}\r\n\r\n/**\r\n * Customized material\r\n */\r\nexport class CustomMaterial extends StandardMaterial {\r\n    /**\r\n     * Index for each created shader\r\n     */\r\n    public static ShaderIndexer = 1;\r\n    /**\r\n     * Custom shader structure\r\n     */\r\n    public CustomParts: ShaderSpecialParts;\r\n    /**\r\n     * Name of the shader\r\n     */\r\n    public _createdShaderName: string;\r\n    /**\r\n     * List of custom uniforms\r\n     */\r\n    public _customUniform: string[];\r\n    /**\r\n     * Names of the new uniforms\r\n     */\r\n    public _newUniforms: string[];\r\n    /**\r\n     * Instances of the new uniform objects\r\n     */\r\n    public _newUniformInstances: { [name: string]: any };\r\n    /**\r\n     * Instances of the new sampler objects\r\n     */\r\n    public _newSamplerInstances: { [name: string]: Texture };\r\n    /**\r\n     * List of the custom attributes\r\n     */\r\n    public _customAttributes: string[];\r\n\r\n    /**\r\n     * Fragment shader string\r\n     */\r\n    public FragmentShader: string;\r\n    /**\r\n     * Vertex shader string\r\n     */\r\n    public VertexShader: string;\r\n\r\n    /**\r\n     * Runs after the material is bound to a mesh\r\n     * @param mesh mesh bound\r\n     * @param effect bound effect used to render\r\n     */\r\n    public AttachAfterBind(mesh: Mesh | undefined, effect: Effect) {\r\n        if (this._newUniformInstances) {\r\n            for (const el in this._newUniformInstances) {\r\n                const ea = el.toString().split(\"-\");\r\n                if (ea[0] == \"vec2\") {\r\n                    effect.setVector2(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"vec3\") {\r\n                    if (this._newUniformInstances[el] instanceof Color3) {\r\n                        effect.setColor3(ea[1], this._newUniformInstances[el]);\r\n                    } else {\r\n                        effect.setVector3(ea[1], this._newUniformInstances[el]);\r\n                    }\r\n                } else if (ea[0] == \"vec4\") {\r\n                    if (this._newUniformInstances[el] instanceof Color4) {\r\n                        effect.setDirectColor4(ea[1], this._newUniformInstances[el]);\r\n                    } else {\r\n                        effect.setVector4(ea[1], this._newUniformInstances[el]);\r\n                    }\r\n                    effect.setVector4(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"mat4\") {\r\n                    effect.setMatrix(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"float\") {\r\n                    effect.setFloat(ea[1], this._newUniformInstances[el]);\r\n                }\r\n            }\r\n        }\r\n        if (this._newSamplerInstances) {\r\n            for (const el in this._newSamplerInstances) {\r\n                const ea = el.toString().split(\"-\");\r\n                if (ea[0] == \"sampler2D\" && this._newSamplerInstances[el].isReady && this._newSamplerInstances[el].isReady()) {\r\n                    effect.setTexture(ea[1], this._newSamplerInstances[el]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public ReviewUniform(name: string, arr: string[]): string[] {\r\n        if (name == \"uniform\" && this._newUniforms) {\r\n            for (let ind = 0; ind < this._newUniforms.length; ind++) {\r\n                if (this._customUniform[ind].indexOf(\"sampler\") == -1) {\r\n                    arr.push(this._newUniforms[ind].replace(/\\[\\d*\\]/g, \"\"));\r\n                }\r\n            }\r\n        }\r\n        if (name == \"sampler\" && this._newUniforms) {\r\n            for (let ind = 0; ind < this._newUniforms.length; ind++) {\r\n                if (this._customUniform[ind].indexOf(\"sampler\") != -1) {\r\n                    arr.push(this._newUniforms[ind].replace(/\\[\\d*\\]/g, \"\"));\r\n                }\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    /**\r\n     * Builds the material\r\n     * @param shaderName name of the shader\r\n     * @param uniforms list of uniforms\r\n     * @param uniformBuffers list of uniform buffers\r\n     * @param samplers list of samplers\r\n     * @param defines list of defines\r\n     * @param attributes list of attributes\r\n     * @returns the shader name\r\n     */\r\n    public Builder(shaderName: string, uniforms: string[], uniformBuffers: string[], samplers: string[], defines: MaterialDefines | string[], attributes?: string[]): string {\r\n        if (attributes && this._customAttributes && this._customAttributes.length > 0) {\r\n            attributes.push(...this._customAttributes);\r\n        }\r\n\r\n        this.ReviewUniform(\"uniform\", uniforms);\r\n        this.ReviewUniform(\"sampler\", samplers);\r\n\r\n        const name = this._createdShaderName;\r\n\r\n        if (Effect.ShadersStore[name + \"VertexShader\"] && Effect.ShadersStore[name + \"PixelShader\"]) {\r\n            return name;\r\n        }\r\n        Effect.ShadersStore[name + \"VertexShader\"] = this._injectCustomCode(this.VertexShader, \"vertex\");\r\n        Effect.ShadersStore[name + \"PixelShader\"] = this._injectCustomCode(this.FragmentShader, \"fragment\");\r\n\r\n        return name;\r\n    }\r\n\r\n    protected _injectCustomCode(code: string, shaderType: string): string {\r\n        const customCode = this._getCustomCode(shaderType);\r\n\r\n        for (const point in customCode) {\r\n            const injectedCode = customCode[point];\r\n\r\n            if (injectedCode && injectedCode.length > 0) {\r\n                const fullPointName = \"#define \" + point;\r\n                code = code.replace(fullPointName, \"\\n\" + injectedCode + \"\\n\" + fullPointName);\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _getCustomCode(shaderType: string): { [pointName: string]: string } {\r\n        if (shaderType === \"vertex\") {\r\n            return {\r\n                CUSTOM_VERTEX_BEGIN: this.CustomParts.Vertex_Begin,\r\n                CUSTOM_VERTEX_DEFINITIONS: (this._customUniform?.join(\"\\n\") || \"\") + (this.CustomParts.Vertex_Definitions || \"\"),\r\n                CUSTOM_VERTEX_MAIN_BEGIN: this.CustomParts.Vertex_MainBegin,\r\n                CUSTOM_VERTEX_UPDATE_POSITION: this.CustomParts.Vertex_Before_PositionUpdated,\r\n                CUSTOM_VERTEX_UPDATE_NORMAL: this.CustomParts.Vertex_Before_NormalUpdated,\r\n                CUSTOM_VERTEX_MAIN_END: this.CustomParts.Vertex_MainEnd,\r\n                CUSTOM_VERTEX_UPDATE_WORLDPOS: this.CustomParts.Vertex_After_WorldPosComputed,\r\n            };\r\n        }\r\n        return {\r\n            CUSTOM_FRAGMENT_BEGIN: this.CustomParts.Fragment_Begin,\r\n            CUSTOM_FRAGMENT_DEFINITIONS: (this._customUniform?.join(\"\\n\") || \"\") + (this.CustomParts.Fragment_Definitions || \"\"),\r\n            CUSTOM_FRAGMENT_MAIN_BEGIN: this.CustomParts.Fragment_MainBegin,\r\n            CUSTOM_FRAGMENT_UPDATE_DIFFUSE: this.CustomParts.Fragment_Custom_Diffuse,\r\n            CUSTOM_FRAGMENT_UPDATE_ALPHA: this.CustomParts.Fragment_Custom_Alpha,\r\n            CUSTOM_FRAGMENT_BEFORE_LIGHTS: this.CustomParts.Fragment_Before_Lights,\r\n            CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: this.CustomParts.Fragment_Before_FragColor,\r\n            CUSTOM_FRAGMENT_MAIN_END: this.CustomParts.Fragment_MainEnd,\r\n            CUSTOM_FRAGMENT_BEFORE_FOG: this.CustomParts.Fragment_Before_Fog,\r\n        };\r\n    }\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene, true);\r\n        this.CustomParts = new ShaderSpecialParts();\r\n        this.customShaderNameResolve = this.Builder;\r\n\r\n        this.FragmentShader = Effect.ShadersStore[\"defaultPixelShader\"];\r\n        this.VertexShader = Effect.ShadersStore[\"defaultVertexShader\"];\r\n\r\n        CustomMaterial.ShaderIndexer++;\r\n        this._createdShaderName = \"custom_\" + CustomMaterial.ShaderIndexer;\r\n    }\r\n\r\n    protected override _afterBind(mesh?: Mesh, effect: Nullable<Effect> = null, subMesh?: SubMesh): void {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this.AttachAfterBind(mesh, effect);\r\n        try {\r\n            super._afterBind(mesh, effect, subMesh);\r\n        } catch (e) {}\r\n    }\r\n\r\n    /**\r\n     * Adds a new uniform to the shader\r\n     * @param name the name of the uniform to add\r\n     * @param kind the type of the uniform to add\r\n     * @param param the value of the uniform to add\r\n     * @returns the current material\r\n     */\r\n    public AddUniform(name: string, kind: string, param: any): CustomMaterial {\r\n        if (!this._customUniform) {\r\n            this._customUniform = [];\r\n            this._newUniforms = [];\r\n            this._newSamplerInstances = {};\r\n            this._newUniformInstances = {};\r\n        }\r\n        if (param) {\r\n            if (kind.indexOf(\"sampler\") != -1) {\r\n                (<any>this._newSamplerInstances)[kind + \"-\" + name] = param;\r\n            } else {\r\n                (<any>this._newUniformInstances)[kind + \"-\" + name] = param;\r\n            }\r\n        }\r\n        this._customUniform.push(\"uniform \" + kind + \" \" + name + \";\");\r\n        this._newUniforms.push(name);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a custom attribute\r\n     * @param name the name of the attribute\r\n     * @returns the current material\r\n     */\r\n    public AddAttribute(name: string): CustomMaterial {\r\n        if (!this._customAttributes) {\r\n            this._customAttributes = [];\r\n        }\r\n\r\n        this._customAttributes.push(name);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Begin portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Begin(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Begin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Definitions portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Definitions(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Definitions = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_MainBegin portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_MainBegin(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_MainBegin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_MainEnd portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_MainEnd(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_MainEnd = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Custom_Diffuse portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Custom_Diffuse(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Custom_Diffuse = shaderPart.replace(\"result\", \"diffuseColor\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Custom_Alpha portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Custom_Alpha(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Custom_Alpha = shaderPart.replace(\"result\", \"alpha\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Before_Lights portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Before_Lights(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Before_Lights = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Before_Fog portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Before_Fog(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Before_Fog = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Before_FragColor portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Before_FragColor(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Before_FragColor = shaderPart.replace(\"result\", \"color\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_Begin portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_Begin(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_Begin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_Definitions portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_Definitions(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_Definitions = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_MainBegin portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_MainBegin(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_MainBegin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_Before_PositionUpdated portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_Before_PositionUpdated(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_Before_PositionUpdated = shaderPart.replace(\"result\", \"positionUpdated\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_Before_NormalUpdated portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_Before_NormalUpdated(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_Before_NormalUpdated = shaderPart.replace(\"result\", \"normalUpdated\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_After_WorldPosComputed portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_After_WorldPosComputed(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_After_WorldPosComputed = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_MainEnd portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_MainEnd(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_MainEnd = shaderPart;\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CustomMaterial\", CustomMaterial);\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport type { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { ShaderCodeInliner } from \"core/Engines/Processors/shaderCodeInliner\";\r\nimport type { ICustomShaderNameResolveOptions } from \"core/Materials/material\";\r\nimport { Color3, Color4 } from \"core/Maths/math.color\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\n\r\nimport \"core/Shaders/pbr.vertex\";\r\nimport \"core/Shaders/pbr.fragment\";\r\n\r\n/**\r\n * Albedo parts of the shader\r\n */\r\nexport class ShaderAlbedoParts {\r\n    constructor() {}\r\n\r\n    /**\r\n     * Beginning of the fragment shader\r\n     */\r\n    public Fragment_Begin: string;\r\n    /**\r\n     * Fragment definitions\r\n     */\r\n    public Fragment_Definitions: string;\r\n    /**\r\n     * Beginning of the main function\r\n     */\r\n    public Fragment_MainBegin: string;\r\n    /**\r\n     * End of main function\r\n     */\r\n    public Fragment_MainEnd: string;\r\n\r\n    /**\r\n     * Albedo color\r\n     */\r\n    public Fragment_Custom_Albedo: string;\r\n    /**\r\n     * Lights\r\n     */\r\n    public Fragment_Before_Lights: string;\r\n    /**\r\n     * Metallic and roughness\r\n     */\r\n    public Fragment_Custom_MetallicRoughness: string;\r\n    /**\r\n     * Microsurface\r\n     */\r\n    public Fragment_Custom_MicroSurface: string;\r\n    /**\r\n     * Fog computations\r\n     */\r\n    public Fragment_Before_Fog: string;\r\n    /**\r\n     * Alpha\r\n     */\r\n    public Fragment_Custom_Alpha: string;\r\n    /**\r\n     * Color composition\r\n     */\r\n    public Fragment_Before_FinalColorComposition: string;\r\n    /**\r\n     * Fragment color\r\n     */\r\n    public Fragment_Before_FragColor: string;\r\n\r\n    /**\r\n     * Beginning of vertex shader\r\n     */\r\n    public Vertex_Begin: string;\r\n    /**\r\n     * Vertex definitions\r\n     */\r\n    public Vertex_Definitions: string;\r\n    /**\r\n     * Vertex main begin\r\n     */\r\n    public Vertex_MainBegin: string;\r\n\r\n    /**\r\n     * Vertex before position updated\r\n     */\r\n    public Vertex_Before_PositionUpdated: string;\r\n\r\n    /**\r\n     * Vertex before normal updated\r\n     */\r\n    public Vertex_Before_NormalUpdated: string;\r\n\r\n    /**\r\n     * Vertex after world pos computed\r\n     */\r\n    public Vertex_After_WorldPosComputed: string;\r\n\r\n    /**\r\n     * Vertex main end\r\n     */\r\n    public Vertex_MainEnd: string;\r\n}\r\n\r\n/**\r\n * @deprecated use ShaderAlbedoParts instead.\r\n */\r\nexport const ShaderAlebdoParts = ShaderAlbedoParts;\r\n\r\nexport class PBRCustomMaterial extends PBRMaterial {\r\n    /**\r\n     * Index for each created shader\r\n     */\r\n    public static ShaderIndexer = 1;\r\n    /**\r\n     * Custom shader structure\r\n     */\r\n    public CustomParts: ShaderAlbedoParts;\r\n    /**\r\n     * Name of the shader\r\n     */\r\n    _createdShaderName: string;\r\n    /**\r\n     * List of custom uniforms\r\n     */\r\n    _customUniform: string[];\r\n    /**\r\n     * Names of the new uniforms\r\n     */\r\n    _newUniforms: string[];\r\n    /**\r\n     * Instances of the new uniform objects\r\n     */\r\n    _newUniformInstances: { [name: string]: any };\r\n    /**\r\n     * Instances of the new sampler objects\r\n     */\r\n    _newSamplerInstances: { [name: string]: Texture };\r\n    /**\r\n     * List of the custom attributes\r\n     */\r\n    _customAttributes: string[];\r\n\r\n    /**\r\n     * Fragment shader string\r\n     */\r\n    public FragmentShader: string;\r\n    /**\r\n     * Vertex shader string\r\n     */\r\n    public VertexShader: string;\r\n\r\n    /**\r\n     * Runs after the material is bound to a mesh\r\n     * @param mesh mesh bound\r\n     * @param effect bound effect used to render\r\n     */\r\n    public AttachAfterBind(mesh: Mesh | undefined, effect: Effect) {\r\n        if (this._newUniformInstances) {\r\n            for (const el in this._newUniformInstances) {\r\n                const ea = el.toString().split(\"-\");\r\n                if (ea[0] == \"vec2\") {\r\n                    effect.setVector2(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"vec3\") {\r\n                    if (this._newUniformInstances[el] instanceof Color3) {\r\n                        effect.setColor3(ea[1], this._newUniformInstances[el]);\r\n                    } else {\r\n                        effect.setVector3(ea[1], this._newUniformInstances[el]);\r\n                    }\r\n                } else if (ea[0] == \"vec4\") {\r\n                    if (this._newUniformInstances[el] instanceof Color4) {\r\n                        effect.setDirectColor4(ea[1], this._newUniformInstances[el]);\r\n                    } else {\r\n                        effect.setVector4(ea[1], this._newUniformInstances[el]);\r\n                    }\r\n                    effect.setVector4(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"mat4\") {\r\n                    effect.setMatrix(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"float\") {\r\n                    effect.setFloat(ea[1], this._newUniformInstances[el]);\r\n                }\r\n            }\r\n        }\r\n        if (this._newSamplerInstances) {\r\n            for (const el in this._newSamplerInstances) {\r\n                const ea = el.toString().split(\"-\");\r\n                if (ea[0] == \"sampler2D\" && this._newSamplerInstances[el].isReady && this._newSamplerInstances[el].isReady()) {\r\n                    effect.setTexture(ea[1], this._newSamplerInstances[el]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public ReviewUniform(name: string, arr: string[]): string[] {\r\n        if (name == \"uniform\" && this._newUniforms) {\r\n            for (let ind = 0; ind < this._newUniforms.length; ind++) {\r\n                if (this._customUniform[ind].indexOf(\"sampler\") == -1) {\r\n                    arr.push(this._newUniforms[ind].replace(/\\[\\d*\\]/g, \"\"));\r\n                }\r\n            }\r\n        }\r\n        if (name == \"sampler\" && this._newUniforms) {\r\n            for (let ind = 0; ind < this._newUniforms.length; ind++) {\r\n                if (this._customUniform[ind].indexOf(\"sampler\") != -1) {\r\n                    arr.push(this._newUniforms[ind].replace(/\\[\\d*\\]/g, \"\"));\r\n                }\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    /**\r\n     * Builds the material\r\n     * @param shaderName name of the shader\r\n     * @param uniforms list of uniforms\r\n     * @param uniformBuffers list of uniform buffers\r\n     * @param samplers list of samplers\r\n     * @param defines list of defines\r\n     * @param attributes list of attributes\r\n     * @param options options to compile the shader\r\n     * @returns the shader name\r\n     */\r\n    public Builder(\r\n        shaderName: string,\r\n        uniforms: string[],\r\n        uniformBuffers: string[],\r\n        samplers: string[],\r\n        defines: MaterialDefines | string[],\r\n        attributes?: string[],\r\n        options?: ICustomShaderNameResolveOptions\r\n    ): string {\r\n        if (options) {\r\n            const currentProcessing = options.processFinalCode;\r\n            options.processFinalCode = (type: string, code: string) => {\r\n                if (type === \"vertex\") {\r\n                    return currentProcessing ? currentProcessing(type, code) : code;\r\n                }\r\n                const sci = new ShaderCodeInliner(code);\r\n                sci.inlineToken = \"#define pbr_inline\";\r\n                sci.processCode();\r\n                return currentProcessing ? currentProcessing(type, sci.code) : sci.code;\r\n            };\r\n        }\r\n\r\n        if (attributes && this._customAttributes && this._customAttributes.length > 0) {\r\n            attributes.push(...this._customAttributes);\r\n        }\r\n\r\n        this.ReviewUniform(\"uniform\", uniforms);\r\n        this.ReviewUniform(\"sampler\", samplers);\r\n\r\n        const name = this._createdShaderName;\r\n\r\n        if (Effect.ShadersStore[name + \"VertexShader\"] && Effect.ShadersStore[name + \"PixelShader\"]) {\r\n            return name;\r\n        }\r\n        Effect.ShadersStore[name + \"VertexShader\"] = this._injectCustomCode(this.VertexShader, \"vertex\");\r\n        Effect.ShadersStore[name + \"PixelShader\"] = this._injectCustomCode(this.FragmentShader, \"fragment\");\r\n\r\n        return name;\r\n    }\r\n\r\n    protected _injectCustomCode(code: string, shaderType: string): string {\r\n        const customCode = this._getCustomCode(shaderType);\r\n\r\n        for (const point in customCode) {\r\n            const injectedCode = customCode[point];\r\n\r\n            if (injectedCode && injectedCode.length > 0) {\r\n                const fullPointName = \"#define \" + point;\r\n                code = code.replace(fullPointName, \"\\n\" + injectedCode + \"\\n\" + fullPointName);\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _getCustomCode(shaderType: string): { [pointName: string]: string } {\r\n        if (shaderType === \"vertex\") {\r\n            return {\r\n                CUSTOM_VERTEX_BEGIN: this.CustomParts.Vertex_Begin,\r\n                CUSTOM_VERTEX_DEFINITIONS: (this._customUniform?.join(\"\\n\") || \"\") + (this.CustomParts.Vertex_Definitions || \"\"),\r\n                CUSTOM_VERTEX_MAIN_BEGIN: this.CustomParts.Vertex_MainBegin,\r\n                CUSTOM_VERTEX_UPDATE_POSITION: this.CustomParts.Vertex_Before_PositionUpdated,\r\n                CUSTOM_VERTEX_UPDATE_NORMAL: this.CustomParts.Vertex_Before_NormalUpdated,\r\n                CUSTOM_VERTEX_MAIN_END: this.CustomParts.Vertex_MainEnd,\r\n                CUSTOM_VERTEX_UPDATE_WORLDPOS: this.CustomParts.Vertex_After_WorldPosComputed,\r\n            };\r\n        }\r\n        return {\r\n            CUSTOM_FRAGMENT_BEGIN: this.CustomParts.Fragment_Begin,\r\n            CUSTOM_FRAGMENT_MAIN_BEGIN: this.CustomParts.Fragment_MainBegin,\r\n            CUSTOM_FRAGMENT_DEFINITIONS: (this._customUniform?.join(\"\\n\") || \"\") + (this.CustomParts.Fragment_Definitions || \"\"),\r\n            CUSTOM_FRAGMENT_UPDATE_ALBEDO: this.CustomParts.Fragment_Custom_Albedo,\r\n            CUSTOM_FRAGMENT_UPDATE_ALPHA: this.CustomParts.Fragment_Custom_Alpha,\r\n            CUSTOM_FRAGMENT_BEFORE_LIGHTS: this.CustomParts.Fragment_Before_Lights,\r\n            CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS: this.CustomParts.Fragment_Custom_MetallicRoughness,\r\n            CUSTOM_FRAGMENT_UPDATE_MICROSURFACE: this.CustomParts.Fragment_Custom_MicroSurface,\r\n            CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION: this.CustomParts.Fragment_Before_FinalColorComposition,\r\n            CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: this.CustomParts.Fragment_Before_FragColor,\r\n            CUSTOM_FRAGMENT_MAIN_END: this.CustomParts.Fragment_MainEnd,\r\n            CUSTOM_FRAGMENT_BEFORE_FOG: this.CustomParts.Fragment_Before_Fog,\r\n        };\r\n    }\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene, true);\r\n        this.CustomParts = new ShaderAlbedoParts();\r\n        this.customShaderNameResolve = this.Builder;\r\n\r\n        this.FragmentShader = Effect.ShadersStore[\"pbrPixelShader\"];\r\n        this.VertexShader = Effect.ShadersStore[\"pbrVertexShader\"];\r\n\r\n        this.FragmentShader = this.FragmentShader.replace(/#include<pbrBlockAlbedoOpacity>/g, Effect.IncludesShadersStore[\"pbrBlockAlbedoOpacity\"]);\r\n        this.FragmentShader = this.FragmentShader.replace(/#include<pbrBlockReflectivity>/g, Effect.IncludesShadersStore[\"pbrBlockReflectivity\"]);\r\n        this.FragmentShader = this.FragmentShader.replace(/#include<pbrBlockFinalColorComposition>/g, Effect.IncludesShadersStore[\"pbrBlockFinalColorComposition\"]);\r\n\r\n        PBRCustomMaterial.ShaderIndexer++;\r\n        this._createdShaderName = \"custompbr_\" + PBRCustomMaterial.ShaderIndexer;\r\n    }\r\n\r\n    protected override _afterBind(mesh?: Mesh, effect: Nullable<Effect> = null, subMesh?: SubMesh): void {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this.AttachAfterBind(mesh, effect);\r\n        try {\r\n            super._afterBind(mesh, effect, subMesh);\r\n        } catch (e) {}\r\n    }\r\n\r\n    /**\r\n     * Adds a new uniform to the shader\r\n     * @param name the name of the uniform to add\r\n     * @param kind the type of the uniform to add\r\n     * @param param the value of the uniform to add\r\n     * @returns the current material\r\n     */\r\n    public AddUniform(name: string, kind: string, param: any): PBRCustomMaterial {\r\n        if (!this._customUniform) {\r\n            this._customUniform = [];\r\n            this._newUniforms = [];\r\n            this._newSamplerInstances = {};\r\n            this._newUniformInstances = {};\r\n        }\r\n        if (param) {\r\n            if (kind.indexOf(\"sampler\") != -1) {\r\n                (<any>this._newSamplerInstances)[kind + \"-\" + name] = param;\r\n            } else {\r\n                (<any>this._newUniformInstances)[kind + \"-\" + name] = param;\r\n            }\r\n        }\r\n        this._customUniform.push(\"uniform \" + kind + \" \" + name + \";\");\r\n        this._newUniforms.push(name);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a custom attribute\r\n     * @param name the name of the attribute\r\n     * @returns the current material\r\n     */\r\n    public AddAttribute(name: string): PBRCustomMaterial {\r\n        if (!this._customAttributes) {\r\n            this._customAttributes = [];\r\n        }\r\n\r\n        this._customAttributes.push(name);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Begin portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Begin(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Begin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Definitions portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Definitions(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Definitions = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_MainBegin portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_MainBegin(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_MainBegin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Custom_Albedo portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Custom_Albedo(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Custom_Albedo = shaderPart.replace(\"result\", \"surfaceAlbedo\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Custom_Alpha portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Custom_Alpha(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Custom_Alpha = shaderPart.replace(\"result\", \"alpha\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Before_Lights portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Before_Lights(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Before_Lights = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Custom_MetallicRoughness portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Custom_MetallicRoughness(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Custom_MetallicRoughness = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Custom_MicroSurface portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Custom_MicroSurface(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Custom_MicroSurface = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Before_Fog portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Before_Fog(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Before_Fog = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Before_FinalColorComposition portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Before_FinalColorComposition(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Before_FinalColorComposition = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Before_FragColor portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Before_FragColor(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Before_FragColor = shaderPart.replace(\"result\", \"color\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_MainEnd portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_MainEnd(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_MainEnd = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_Begin portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_Begin(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_Begin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_Definitions portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_Definitions(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_Definitions = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_MainBegin portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_MainBegin(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_MainBegin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_Before_PositionUpdated portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_Before_PositionUpdated(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_Before_PositionUpdated = shaderPart.replace(\"result\", \"positionUpdated\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_Before_NormalUpdated portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_Before_NormalUpdated(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_Before_NormalUpdated = shaderPart.replace(\"result\", \"normalUpdated\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_After_WorldPosComputed portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_After_WorldPosComputed(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_After_WorldPosComputed = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_MainEnd portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_MainEnd(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_MainEnd = shaderPart;\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PBRCustomMaterial\", PBRCustomMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"firePixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;varying vec3 vPositionW;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;\n#endif\nuniform sampler2D distortionSampler;uniform sampler2D opacitySampler;\n#ifdef DIFFUSE\nvarying vec2 vDistortionCoords1;varying vec2 vDistortionCoords2;varying vec2 vDistortionCoords3;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvec4 bx2(vec4 x)\n{return vec4(2.0)*x-vec4(1.0);}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);float alpha=1.0;\n#ifdef DIFFUSE\nconst float distortionAmount0 =0.092;const float distortionAmount1 =0.092;const float distortionAmount2 =0.092;vec2 heightAttenuation=vec2(0.3,0.39);vec4 noise0=texture2D(distortionSampler,vDistortionCoords1);vec4 noise1=texture2D(distortionSampler,vDistortionCoords2);vec4 noise2=texture2D(distortionSampler,vDistortionCoords3);vec4 noiseSum=bx2(noise0)*distortionAmount0+bx2(noise1)*distortionAmount1+bx2(noise2)*distortionAmount2;vec4 perturbedBaseCoords=vec4(vDiffuseUV,0.0,1.0)+noiseSum*(vDiffuseUV.y*heightAttenuation.x+heightAttenuation.y);vec4 opacityColor=texture2D(opacitySampler,perturbedBaseCoords.xy);\n#ifdef ALPHATEST\nif (opacityColor.r<0.1)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor=texture2D(diffuseSampler,perturbedBaseCoords.xy)*2.0;baseColor*=opacityColor;baseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\nvec3 diffuseBase=vec3(1.0,1.0,1.0);\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\nvec4 color=vec4(baseColor.rgb,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const firePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"fireVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\nuniform float time;uniform float speed;\n#ifdef DIFFUSE\nvarying vec2 vDistortionCoords1;varying vec2 vDistortionCoords2;varying vec2 vDistortionCoords3;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#ifdef VERTEXCOLOR\nvec4 colorUpdated=color;\n#endif\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef DIFFUSE\nvDiffuseUV=uv;vDiffuseUV.y-=0.2;\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#ifdef DIFFUSE\nvec3 layerSpeed=vec3(-0.2,-0.52,-0.1)*speed;vDistortionCoords1.x=uv.x;vDistortionCoords1.y=uv.y+layerSpeed.x*time/1000.0;vDistortionCoords2.x=uv.x;vDistortionCoords2.y=uv.y+layerSpeed.y*time/1000.0;vDistortionCoords3.x=uv.x;vDistortionCoords3.y=uv.y+layerSpeed.z*time/1000.0;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const fireVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tags } from \"core/Misc/tags\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\n\r\nimport \"./fire.fragment\";\r\nimport \"./fire.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLogDepth,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass FireMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public UV1 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public BonesPerMesh = 0;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class FireMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: Nullable<BaseTexture>;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"distortionTexture\")\r\n    private _distortionTexture: Nullable<BaseTexture>;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public distortionTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"opacityTexture\")\r\n    private _opacityTexture: Nullable<BaseTexture>;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public opacityTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsColor3(\"diffuse\")\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize()\r\n    public speed = 1.0;\r\n\r\n    private _scaledDiffuse = new Color3();\r\n    private _lastTime: number = 0;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public override needAlphaBlending(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public override needAlphaTesting(): boolean {\r\n        return true;\r\n    }\r\n\r\n    public override getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new FireMaterialDefines();\r\n        }\r\n\r\n        const defines = <FireMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                if (!this._diffuseTexture.isReady()) {\r\n                    return false;\r\n                } else {\r\n                    defines._needUVs = true;\r\n                    defines.DIFFUSE = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        defines.ALPHATEST = this._opacityTexture ? true : false;\r\n\r\n        // Misc.\r\n        if (defines._areMiscDirty) {\r\n            defines.POINTSIZE = this.pointsCloud || scene.forcePointsCloud;\r\n            defines.FOG = scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE && this.fogEnabled;\r\n            defines.LOGARITHMICDEPTH = this._useLogarithmicDepth;\r\n        }\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, false, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"fire\";\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n                \"logarithmicDepthConstant\",\r\n                // Fire\r\n                \"time\",\r\n                \"speed\",\r\n            ];\r\n            AddClipPlaneUniforms(uniforms);\r\n\r\n            const join = defines.toString();\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    {\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: [],\r\n                        samplers: [\r\n                            \"diffuseSampler\",\r\n                            // Fire\r\n                            \"distortionSampler\",\r\n                            \"opacitySampler\",\r\n                        ],\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: null,\r\n                        maxSimultaneousLights: 4,\r\n                        transformFeedbackVaryings: null,\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <FireMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this._diffuseTexture.getTextureMatrix());\r\n\r\n                this._activeEffect.setTexture(\"distortionSampler\", this._distortionTexture);\r\n                this._activeEffect.setTexture(\"opacitySampler\", this._opacityTexture);\r\n            }\r\n\r\n            // Clip plane\r\n            BindClipPlane(this._activeEffect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this._scaledDiffuse, this.alpha * mesh.visibility);\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        // Time\r\n        this._lastTime += scene.getEngine().getDeltaTime();\r\n        this._activeEffect.setFloat(\"time\", this._lastTime);\r\n\r\n        // Speed\r\n        this._activeEffect.setFloat(\"speed\", this.speed);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public override getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\r\n            results.push(this._diffuseTexture);\r\n        }\r\n        if (this._distortionTexture && this._distortionTexture.animations && this._distortionTexture.animations.length > 0) {\r\n            results.push(this._distortionTexture);\r\n        }\r\n        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\r\n            results.push(this._opacityTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public override getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        if (this._distortionTexture) {\r\n            activeTextures.push(this._distortionTexture);\r\n        }\r\n\r\n        if (this._opacityTexture) {\r\n            activeTextures.push(this._opacityTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._distortionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._opacityTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"FireMaterial\";\r\n    }\r\n\r\n    public override dispose(forceDisposeEffect?: boolean): void {\r\n        if (this._diffuseTexture) {\r\n            this._diffuseTexture.dispose();\r\n        }\r\n        if (this._distortionTexture) {\r\n            this._distortionTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public override clone(name: string): FireMaterial {\r\n        return SerializationHelper.Clone<FireMaterial>(() => new FireMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.FireMaterial\";\r\n        serializationObject.diffuseColor = this.diffuseColor.asArray();\r\n        serializationObject.speed = this.speed;\r\n\r\n        if (this._diffuseTexture) {\r\n            serializationObject._diffuseTexture = this._diffuseTexture.serialize();\r\n        }\r\n\r\n        if (this._distortionTexture) {\r\n            serializationObject._distortionTexture = this._distortionTexture.serialize();\r\n        }\r\n\r\n        if (this._opacityTexture) {\r\n            serializationObject._opacityTexture = this._opacityTexture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): FireMaterial {\r\n        const material = new FireMaterial(source.name, scene);\r\n\r\n        material.diffuseColor = Color3.FromArray(source.diffuseColor);\r\n        material.speed = source.speed;\r\n\r\n        material.alpha = source.alpha;\r\n\r\n        material.id = source.id;\r\n\r\n        Tags.AddTagsTo(material, source.tags);\r\n        material.backFaceCulling = source.backFaceCulling;\r\n        material.wireframe = source.wireframe;\r\n\r\n        if (source._diffuseTexture) {\r\n            material._diffuseTexture = Texture.Parse(source._diffuseTexture, scene, rootUrl);\r\n        }\r\n\r\n        if (source._distortionTexture) {\r\n            material._distortionTexture = Texture.Parse(source._distortionTexture, scene, rootUrl);\r\n        }\r\n\r\n        if (source._opacityTexture) {\r\n            material._opacityTexture = Texture.Parse(source._opacityTexture, scene, rootUrl);\r\n        }\r\n\r\n        return material;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FireMaterial\", FireMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"furPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;uniform vec4 furColor;uniform float furLength;varying vec3 vPositionW;varying float vfur_length;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef HIGHLEVEL\nuniform float furOffset;uniform float furOcclusion;uniform sampler2D furTexture;varying vec2 vFurUV;\n#endif\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<fogFragmentDeclaration>\n#include<clipPlaneFragmentDeclaration>\nfloat Rand(vec3 rv) {float x=dot(rv,vec3(12.9898,78.233,24.65487));return fract(sin(x)*43758.5453);}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=furColor;vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef DIFFUSE\nbaseColor*=texture2D(diffuseSampler,vDiffuseUV);\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#ifdef HIGHLEVEL\nvec4 furTextureColor=texture2D(furTexture,vec2(vFurUV.x,vFurUV.y));if (furTextureColor.a<=0.0 || furTextureColor.g<furOffset) {discard;}\nfloat occlusion=mix(0.0,furTextureColor.b*1.2,furOffset);baseColor=vec4(baseColor.xyz*max(occlusion,furOcclusion),1.1-furOffset);\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\nvec3 finalDiffuse=clamp(diffuseBase.rgb*baseColor.rgb,0.0,1.0);\n#ifdef HIGHLEVEL\nvec4 color=vec4(finalDiffuse,alpha);\n#else\nfloat r=vfur_length/furLength*0.5;vec4 color=vec4(finalDiffuse*(0.5+r),alpha);\n#endif\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const furPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"furVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;attribute vec3 normal;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\nuniform float furLength;uniform float furAngle;\n#ifdef HIGHLEVEL\nuniform float furOffset;uniform vec3 furGravity;uniform float furTime;uniform float furSpacing;uniform float furDensity;\n#endif\n#ifdef HEIGHTMAP\nuniform sampler2D heightTexture;\n#endif\n#ifdef HIGHLEVEL\nvarying vec2 vFurUV;\n#endif\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\nvarying float vfur_length;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\nfloat Rand(vec3 rv) {float x=dot(rv,vec3(12.9898,78.233,24.65487));return fract(sin(x)*43758.5453);}\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#ifdef VERTEXCOLOR\nvec4 colorUpdated=color;\n#endif\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nfloat r=Rand(position);\n#ifdef HEIGHTMAP\n#if __VERSION__>100\nvfur_length=furLength*texture(heightTexture,uv).x;\n#else\nvfur_length=furLength*texture2D(heightTexture,uv).r;\n#endif\n#else \nvfur_length=(furLength*r);\n#endif\nvec3 tangent1=vec3(normal.y,-normal.x,0);vec3 tangent2=vec3(-normal.z,0,normal.x);r=Rand(tangent1*r);float J=(2.0+4.0*r);r=Rand(tangent2*r);float K=(2.0+2.0*r);tangent1=tangent1*J+tangent2*K;tangent1=normalize(tangent1);vec3 newPosition=position+normal*vfur_length*cos(furAngle)+tangent1*vfur_length*sin(furAngle);\n#ifdef HIGHLEVEL\nvec3 forceDirection=vec3(0.0,0.0,0.0);forceDirection.x=sin(furTime+position.x*0.05)*0.2;forceDirection.y=cos(furTime*0.7+position.y*0.04)*0.2;forceDirection.z=sin(furTime*0.7+position.z*0.04)*0.2;vec3 displacement=vec3(0.0,0.0,0.0);displacement=furGravity+forceDirection;float displacementFactor=pow(furOffset,3.0);vec3 aNormal=normal;aNormal.xyz+=displacement*displacementFactor;newPosition=vec3(newPosition.x,newPosition.y,newPosition.z)+(normalize(aNormal)*furOffset*furSpacing);\n#endif\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\ngl_Position=viewProjection*finalWorld*vec4(newPosition,1.0);vec4 worldPos=finalWorld*vec4(newPosition,1.0);vPositionW=vec3(worldPos);\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x==0.)\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}\nelse\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}\n#ifdef HIGHLEVEL\nvFurUV=vDiffuseUV*furDensity;\n#endif\n#else\n#ifdef HIGHLEVEL\nvFurUV=uv*furDensity;\n#endif\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const furVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsVector3, serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport { Tags } from \"core/Misc/tags\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { DynamicTexture } from \"core/Materials/Textures/dynamicTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\n\r\nimport \"./fur.fragment\";\r\nimport \"./fur.vertex\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass FurMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public HEIGHTMAP = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public HIGHLEVEL = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public AREALIGHTSUPPORTED = true;\r\n    public AREALIGHTNOROUGHTNESS = true;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class FurMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsTexture(\"heightTexture\")\r\n    private _heightTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public heightTexture: BaseTexture;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize()\r\n    public furLength: number = 1;\r\n\r\n    @serialize()\r\n    public furAngle: number = 0;\r\n\r\n    @serializeAsColor3()\r\n    public furColor = new Color3(0.44, 0.21, 0.02);\r\n\r\n    @serialize()\r\n    public furOffset: number = 0.0;\r\n\r\n    @serialize()\r\n    public furSpacing: number = 12;\r\n\r\n    @serializeAsVector3()\r\n    public furGravity = new Vector3(0, 0, 0);\r\n\r\n    @serialize()\r\n    public furSpeed: number = 100;\r\n\r\n    @serialize()\r\n    public furDensity: number = 20;\r\n\r\n    @serialize()\r\n    public furOcclusion: number = 0.0;\r\n\r\n    public furTexture: DynamicTexture;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    @serialize()\r\n    public highLevelFur: boolean = true;\r\n\r\n    public _meshes: AbstractMesh[];\r\n\r\n    private _furTime: number = 0;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    @serialize()\r\n    public get furTime() {\r\n        return this._furTime;\r\n    }\r\n\r\n    public set furTime(furTime: number) {\r\n        this._furTime = furTime;\r\n    }\r\n\r\n    public override needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public override needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public override getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    public updateFur(): void {\r\n        for (let i = 1; i < this._meshes.length; i++) {\r\n            const offsetFur = <FurMaterial>this._meshes[i].material;\r\n\r\n            offsetFur.furLength = this.furLength;\r\n            offsetFur.furAngle = this.furAngle;\r\n            offsetFur.furGravity = this.furGravity;\r\n            offsetFur.furSpacing = this.furSpacing;\r\n            offsetFur.furSpeed = this.furSpeed;\r\n            offsetFur.furColor = this.furColor;\r\n            offsetFur.diffuseTexture = this.diffuseTexture;\r\n            offsetFur.furTexture = this.furTexture;\r\n            offsetFur.highLevelFur = this.highLevelFur;\r\n            offsetFur.furTime = this.furTime;\r\n            offsetFur.furDensity = this.furDensity;\r\n        }\r\n    }\r\n\r\n    // Methods\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new FurMaterialDefines();\r\n        }\r\n\r\n        const defines = <FurMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this.diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this.diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n                if (this.heightTexture && engine.getCaps().maxVertexTextureImageUnits) {\r\n                    if (!this.heightTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.HEIGHTMAP = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // High level\r\n        if (this.highLevelFur !== defines.HIGHLEVEL) {\r\n            defines.HIGHLEVEL = true;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"fur\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n                \"logarithmicDepthConstant\",\r\n                \"furLength\",\r\n                \"furAngle\",\r\n                \"furColor\",\r\n                \"furOffset\",\r\n                \"furGravity\",\r\n                \"furTime\",\r\n                \"furSpacing\",\r\n                \"furDensity\",\r\n                \"furOcclusion\",\r\n            ];\r\n            AddClipPlaneUniforms(uniforms);\r\n            const samplers = [\"diffuseSampler\", \"heightTexture\", \"furTexture\", \"areaLightsLTC1Sampler\", \"areaLightsLTC2Sampler\"];\r\n\r\n            const uniformBuffers: string[] = [];\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n\r\n        // Check if Area Lights have LTC texture.\r\n        if (defines[\"AREALIGHTUSED\"]) {\r\n            for (let index = 0; index < mesh.lightSources.length; index++) {\r\n                if (!mesh.lightSources[index]._isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <FurMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this._diffuseTexture.getTextureMatrix());\r\n            }\r\n\r\n            if (this._heightTexture) {\r\n                this._activeEffect.setTexture(\"heightTexture\", this._heightTexture);\r\n            }\r\n\r\n            // Clip plane\r\n            BindClipPlane(this._activeEffect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._activeEffect.setFloat(\"furLength\", this.furLength);\r\n        this._activeEffect.setFloat(\"furAngle\", this.furAngle);\r\n        this._activeEffect.setColor4(\"furColor\", this.furColor, 1.0);\r\n\r\n        if (this.highLevelFur) {\r\n            this._activeEffect.setVector3(\"furGravity\", this.furGravity);\r\n            this._activeEffect.setFloat(\"furOffset\", this.furOffset);\r\n            this._activeEffect.setFloat(\"furSpacing\", this.furSpacing);\r\n            this._activeEffect.setFloat(\"furDensity\", this.furDensity);\r\n            this._activeEffect.setFloat(\"furOcclusion\", this.furOcclusion);\r\n\r\n            this._furTime += this.getScene().getEngine().getDeltaTime() / this.furSpeed;\r\n            this._activeEffect.setFloat(\"furTime\", this._furTime);\r\n\r\n            this._activeEffect.setTexture(\"furTexture\", this.furTexture);\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public override getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0) {\r\n            results.push(this.diffuseTexture);\r\n        }\r\n\r\n        if (this.heightTexture && this.heightTexture.animations && this.heightTexture.animations.length > 0) {\r\n            results.push(this.heightTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public override getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        if (this._heightTexture) {\r\n            activeTextures.push(this._heightTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this.diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._heightTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.diffuseTexture) {\r\n            this.diffuseTexture.dispose();\r\n        }\r\n\r\n        if (this._meshes) {\r\n            for (let i = 1; i < this._meshes.length; i++) {\r\n                const mat = this._meshes[i].material;\r\n\r\n                if (mat) {\r\n                    mat.dispose(forceDisposeEffect);\r\n                }\r\n                this._meshes[i].dispose();\r\n            }\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public override clone(name: string): FurMaterial {\r\n        return SerializationHelper.Clone(() => new FurMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.FurMaterial\";\r\n\r\n        if (this._meshes) {\r\n            serializationObject.sourceMeshName = this._meshes[0].name;\r\n            serializationObject.quality = this._meshes.length;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"FurMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): FurMaterial {\r\n        const material = SerializationHelper.Parse(() => new FurMaterial(source.name, scene), source, scene, rootUrl);\r\n\r\n        if (source.sourceMeshName && material.highLevelFur) {\r\n            scene.executeWhenReady(() => {\r\n                const sourceMesh = <Mesh>scene.getMeshByName(source.sourceMeshName);\r\n                if (sourceMesh) {\r\n                    const furTexture = FurMaterial.GenerateTexture(\"Fur Texture\", scene);\r\n                    material.furTexture = furTexture;\r\n                    FurMaterial.FurifyMesh(sourceMesh, source.quality);\r\n                }\r\n            });\r\n        }\r\n\r\n        return material;\r\n    }\r\n\r\n    public static GenerateTexture(name: string, scene: Scene): DynamicTexture {\r\n        // Generate fur textures\r\n        const texture = new DynamicTexture(\"FurTexture \" + name, 256, scene, true);\r\n        const context = texture.getContext();\r\n\r\n        for (let i = 0; i < 20000; ++i) {\r\n            context.fillStyle = \"rgba(255, \" + Math.floor(Math.random() * 255) + \", \" + Math.floor(Math.random() * 255) + \", 1)\";\r\n            context.fillRect(Math.random() * texture.getSize().width, Math.random() * texture.getSize().height, 2, 2);\r\n        }\r\n\r\n        texture.update(false);\r\n        texture.wrapU = Texture.WRAP_ADDRESSMODE;\r\n        texture.wrapV = Texture.WRAP_ADDRESSMODE;\r\n\r\n        return texture;\r\n    }\r\n\r\n    // Creates and returns an array of meshes used as shells for the Fur Material\r\n    // that can be disposed later in your code\r\n    // The quality is in interval [0, 100]\r\n    public static FurifyMesh(sourceMesh: Mesh, quality: number): Mesh[] {\r\n        const meshes = [sourceMesh];\r\n        const mat: FurMaterial = <FurMaterial>sourceMesh.material;\r\n        let i;\r\n\r\n        if (!(mat instanceof FurMaterial)) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"The material of the source mesh must be a Fur Material\";\r\n        }\r\n\r\n        for (i = 1; i < quality; i++) {\r\n            const offsetFur = new FurMaterial(mat.name + i, sourceMesh.getScene());\r\n            sourceMesh.getScene().materials.pop();\r\n            Tags.EnableFor(offsetFur);\r\n            Tags.AddTagsTo(offsetFur, \"furShellMaterial\");\r\n\r\n            offsetFur.furLength = mat.furLength;\r\n            offsetFur.furAngle = mat.furAngle;\r\n            offsetFur.furGravity = mat.furGravity;\r\n            offsetFur.furSpacing = mat.furSpacing;\r\n            offsetFur.furSpeed = mat.furSpeed;\r\n            offsetFur.furColor = mat.furColor;\r\n            offsetFur.diffuseTexture = mat.diffuseTexture;\r\n            offsetFur.furOffset = i / quality;\r\n            offsetFur.furTexture = mat.furTexture;\r\n            offsetFur.highLevelFur = mat.highLevelFur;\r\n            offsetFur.furTime = mat.furTime;\r\n            offsetFur.furDensity = mat.furDensity;\r\n\r\n            const offsetMesh = sourceMesh.clone(sourceMesh.name + i);\r\n\r\n            offsetMesh.material = offsetFur;\r\n            offsetMesh.skeleton = sourceMesh.skeleton;\r\n            offsetMesh.position = Vector3.Zero();\r\n            meshes.push(offsetMesh);\r\n        }\r\n\r\n        for (i = 1; i < meshes.length; i++) {\r\n            meshes[i].parent = sourceMesh;\r\n        }\r\n\r\n        (<FurMaterial>sourceMesh.material)._meshes = meshes;\r\n\r\n        return meshes;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FurMaterial\", FurMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"gradientPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 topColor;uniform vec4 bottomColor;uniform float offset;uniform float scale;uniform float smoothness;varying vec3 vPositionW;varying vec3 vPosition;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0]\n#include<__decl__lightFragment>[1]\n#include<__decl__lightFragment>[2]\n#include<__decl__lightFragment>[3]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);float h=vPosition.y*scale+offset;float mysmoothness=clamp(smoothness,0.01,max(smoothness,10.));vec4 baseColor=mix(bottomColor,topColor,max(pow(max(h,0.0),mysmoothness),0.0));vec3 diffuseColor=baseColor.rgb;float alpha=baseColor.a;\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#ifdef EMISSIVE\nvec3 diffuseBase=baseColor.rgb;\n#else\nvec3 diffuseBase=vec3(0.,0.,0.);\n#endif\nlightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;\n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;vec4 color=vec4(finalDiffuse,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gradientPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"gradientVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;varying vec3 vPosition;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#ifdef VERTEXCOLOR\nvec4 colorUpdated=color;\n#endif\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);vPosition=position;\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gradientVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./gradient.fragment\";\r\nimport \"./gradient.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass GradientMaterialDefines extends MaterialDefines {\r\n    public EMISSIVE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public AREALIGHTSUPPORTED = true;\r\n    public AREALIGHTNOROUGHTNESS = true;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class GradientMaterial extends PushMaterial {\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    // The gradient top color, red by default\r\n    @serializeAsColor3()\r\n    public topColor = new Color3(1, 0, 0);\r\n\r\n    @serialize()\r\n    public topColorAlpha = 1.0;\r\n\r\n    // The gradient top color, blue by default\r\n    @serializeAsColor3()\r\n    public bottomColor = new Color3(0, 0, 1);\r\n\r\n    @serialize()\r\n    public bottomColorAlpha = 1.0;\r\n\r\n    // Gradient offset\r\n    @serialize()\r\n    public offset = 0;\r\n\r\n    @serialize()\r\n    public scale = 1.0;\r\n\r\n    @serialize()\r\n    public smoothness = 1.0;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public override needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0 || this.topColorAlpha < 1.0 || this.bottomColorAlpha < 1.0;\r\n    }\r\n\r\n    public override needAlphaTesting(): boolean {\r\n        return true;\r\n    }\r\n\r\n    public override getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new GradientMaterialDefines();\r\n        }\r\n\r\n        const defines = <GradientMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines);\r\n\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        defines.EMISSIVE = this._disableLighting;\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, false, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"gradient\";\r\n            const join = defines.toString();\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"mBones\",\r\n                \"logarithmicDepthConstant\",\r\n                \"topColor\",\r\n                \"bottomColor\",\r\n                \"offset\",\r\n                \"smoothness\",\r\n                \"scale\",\r\n            ];\r\n            AddClipPlaneUniforms(uniforms);\r\n            const samplers: string[] = [\"areaLightsLTC1Sampler\", \"areaLightsLTC2Sampler\"];\r\n            const uniformBuffers: string[] = [];\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: 4,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: 4 },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n\r\n        // Check if Area Lights have LTC texture.\r\n        if (defines[\"AREALIGHTUSED\"]) {\r\n            for (let index = 0; index < mesh.lightSources.length; index++) {\r\n                if (!mesh.lightSources[index]._isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <GradientMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, effect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Clip plane\r\n            BindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._activeEffect.setColor4(\"topColor\", this.topColor, this.topColorAlpha);\r\n        this._activeEffect.setColor4(\"bottomColor\", this.bottomColor, this.bottomColorAlpha);\r\n        this._activeEffect.setFloat(\"offset\", this.offset);\r\n        this._activeEffect.setFloat(\"scale\", this.scale);\r\n        this._activeEffect.setFloat(\"smoothness\", this.smoothness);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public override getAnimatables(): IAnimatable[] {\r\n        return [];\r\n    }\r\n\r\n    public override dispose(forceDisposeEffect?: boolean): void {\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public override clone(name: string): GradientMaterial {\r\n        return SerializationHelper.Clone(() => new GradientMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.GradientMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"GradientMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): GradientMaterial {\r\n        return SerializationHelper.Parse(() => new GradientMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GradientMaterial\", GradientMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"gridPixelShader\";\nconst shader = `#extension GL_OES_standard_derivatives : enable\n#define SQRT2 1.41421356\n#define PI 3.14159\nprecision highp float;uniform float visibility;uniform vec3 mainColor;uniform vec3 lineColor;uniform vec4 gridControl;uniform vec3 gridOffset;varying vec3 vPosition;varying vec3 vNormal;\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#ifdef OPACITY\nvarying vec2 vOpacityUV;uniform sampler2D opacitySampler;uniform vec2 vOpacityInfos;\n#endif\nfloat getDynamicVisibility(float position) {float majorGridFrequency=gridControl.y;if (floor(position+0.5)==floor(position/majorGridFrequency+0.5)*majorGridFrequency)\n{return 1.0;}\nreturn gridControl.z;}\nfloat getAnisotropicAttenuation(float differentialLength) {const float maxNumberOfLines=10.0;return clamp(1.0/(differentialLength+1.0)-1.0/maxNumberOfLines,0.0,1.0);}\nfloat isPointOnLine(float position,float differentialLength) {float fractionPartOfPosition=position-floor(position+0.5); \nfractionPartOfPosition/=differentialLength; \n#ifdef ANTIALIAS\nfractionPartOfPosition=clamp(fractionPartOfPosition,-1.,1.);float result=0.5+0.5*cos(fractionPartOfPosition*PI); \nreturn result;\n#else\nreturn abs(fractionPartOfPosition)<SQRT2/4. ? 1. : 0.;\n#endif\n}\nfloat contributionOnAxis(float position) {float differentialLength=length(vec2(dFdx(position),dFdy(position)));differentialLength*=SQRT2; \nfloat result=isPointOnLine(position,differentialLength);float dynamicVisibility=getDynamicVisibility(position);result*=dynamicVisibility;float anisotropicAttenuation=getAnisotropicAttenuation(differentialLength);result*=anisotropicAttenuation;return result;}\nfloat normalImpactOnAxis(float x) {float normalImpact=clamp(1.0-3.0*abs(x*x*x),0.0,1.0);return normalImpact;}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nfloat gridRatio=gridControl.x;vec3 gridPos=(vPosition+gridOffset.xyz)/gridRatio;float x=contributionOnAxis(gridPos.x);float y=contributionOnAxis(gridPos.y);float z=contributionOnAxis(gridPos.z);vec3 normal=normalize(vNormal);x*=normalImpactOnAxis(normal.x);y*=normalImpactOnAxis(normal.y);z*=normalImpactOnAxis(normal.z);\n#ifdef MAX_LINE\nfloat grid=clamp(max(max(x,y),z),0.,1.);\n#else\nfloat grid=clamp(x+y+z,0.,1.);\n#endif\nvec3 color=mix(mainColor,lineColor,grid);\n#ifdef FOG\n#include<fogFragment>\n#endif\nfloat opacity=1.0;\n#ifdef TRANSPARENT\nopacity=clamp(grid,0.08,gridControl.w*grid);\n#endif\n#ifdef OPACITY\nopacity*=texture2D(opacitySampler,vOpacityUV).a;\n#endif\ngl_FragColor=vec4(color.rgb,opacity*visibility);\n#ifdef TRANSPARENT\n#ifdef PREMULTIPLYALPHA\ngl_FragColor.rgb*=opacity;\n#endif\n#else\n#endif\n#include<logDepthFragment>\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gridPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/sceneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/sceneUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\n\nconst name = \"gridVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;attribute vec3 normal;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#include<instancesDeclaration>\n#include<__decl__sceneVertex>\nvarying vec3 vPosition;varying vec3 vNormal;\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#ifdef OPACITY\nvarying vec2 vOpacityUV;uniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;\n#endif\n#include<clipPlaneVertexDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\n#include<fogVertex>\nvec4 cameraSpacePosition=view*worldPos;gl_Position=projection*cameraSpacePosition;\n#ifdef OPACITY\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\nif (vOpacityInfos.x==0.)\n{vOpacityUV=vec2(opacityMatrix*vec4(uv,1.0,0.0));}\nelse\n{vOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));}\n#endif \n#include<clipPlaneVertex>\n#include<logDepthVertex>\nvPosition=position;vNormal=normal;\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gridVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, serializeAsVector3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Vector4, Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./grid.fragment\";\r\nimport \"./grid.vertex\";\r\nimport {\r\n    BindFogParameters,\r\n    BindLogDepth,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForMisc,\r\n} from \"core/Materials/materialHelper.functions\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\n\r\nclass GridMaterialDefines extends MaterialDefines {\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public OPACITY = false;\r\n    public ANTIALIAS = false;\r\n    public TRANSPARENT = false;\r\n    public FOG = false;\r\n    public PREMULTIPLYALPHA = false;\r\n    public MAX_LINE = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public INSTANCES = false;\r\n    public THIN_INSTANCES = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\n/**\r\n * The grid materials allows you to wrap any shape with a grid.\r\n * Colors are customizable.\r\n */\r\nexport class GridMaterial extends PushMaterial {\r\n    /**\r\n     * Main color of the grid (e.g. between lines)\r\n     */\r\n    @serializeAsColor3()\r\n    public mainColor = Color3.Black();\r\n\r\n    /**\r\n     * Color of the grid lines.\r\n     */\r\n    @serializeAsColor3()\r\n    public lineColor = Color3.Teal();\r\n\r\n    /**\r\n     * The scale of the grid compared to unit.\r\n     */\r\n    @serialize()\r\n    public gridRatio = 1.0;\r\n\r\n    /**\r\n     * Allows setting an offset for the grid lines.\r\n     */\r\n    @serializeAsVector3()\r\n    public gridOffset = Vector3.Zero();\r\n\r\n    /**\r\n     * The frequency of thicker lines.\r\n     */\r\n    @serialize()\r\n    public majorUnitFrequency = 10;\r\n\r\n    /**\r\n     * The visibility of minor units in the grid.\r\n     */\r\n    @serialize()\r\n    public minorUnitVisibility = 0.33;\r\n\r\n    /**\r\n     * The grid opacity outside of the lines.\r\n     */\r\n    @serialize()\r\n    public opacity = 1.0;\r\n\r\n    /**\r\n     * Whether to antialias the grid\r\n     */\r\n    @serialize()\r\n    public antialias = true;\r\n\r\n    /**\r\n     * Determine RBG output is premultiplied by alpha value.\r\n     */\r\n    @serialize()\r\n    public preMultiplyAlpha = false;\r\n\r\n    /**\r\n     * Determines if the max line value will be used instead of the sum wherever grid lines intersect.\r\n     */\r\n    @serialize()\r\n    public useMaxLine = false;\r\n\r\n    @serializeAsTexture(\"opacityTexture\")\r\n    private _opacityTexture: BaseTexture;\r\n    /**\r\n     * Texture to define opacity of the grid\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public opacityTexture: BaseTexture;\r\n\r\n    private _gridControl: Vector4 = new Vector4(this.gridRatio, this.majorUnitFrequency, this.minorUnitVisibility, this.opacity);\r\n\r\n    /**\r\n     * constructor\r\n     * @param name The name given to the material in order to identify it afterwards.\r\n     * @param scene The scene the material is used in.\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not the grid requires alpha blending.\r\n     */\r\n    public override needAlphaBlending(): boolean {\r\n        return this.opacity < 1.0 || (this._opacityTexture && this._opacityTexture.isReady());\r\n    }\r\n\r\n    public override needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\r\n        return mesh.visibility < 1.0 || this.needAlphaBlending();\r\n    }\r\n\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new GridMaterialDefines();\r\n        }\r\n\r\n        const defines = <GridMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        if (defines.TRANSPARENT !== this.opacity < 1.0) {\r\n            defines.TRANSPARENT = !defines.TRANSPARENT;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        if (defines.PREMULTIPLYALPHA != this.preMultiplyAlpha) {\r\n            defines.PREMULTIPLYALPHA = !defines.PREMULTIPLYALPHA;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        if (defines.MAX_LINE !== this.useMaxLine) {\r\n            defines.MAX_LINE = !defines.MAX_LINE;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        if (defines.ANTIALIAS !== this.antialias) {\r\n            defines.ANTIALIAS = !defines.ANTIALIAS;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                    if (!this._opacityTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.OPACITY = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, false, this.fogEnabled, false, defines);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, scene.getEngine(), this, defines, !!useInstances);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Attributes\r\n            PrepareDefinesForAttributes(mesh, defines, false, false);\r\n            const attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const uniforms = [\r\n                \"projection\",\r\n                \"mainColor\",\r\n                \"lineColor\",\r\n                \"gridControl\",\r\n                \"gridOffset\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"world\",\r\n                \"view\",\r\n                \"opacityMatrix\",\r\n                \"vOpacityInfos\",\r\n                \"visibility\",\r\n                \"logarithmicDepthConstant\",\r\n            ];\r\n            // Defines\r\n            const join = defines.toString();\r\n            AddClipPlaneUniforms(uniforms);\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    \"grid\",\r\n                    {\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: [\"Scene\"],\r\n                        samplers: [\"opacitySampler\"],\r\n                        defines: join,\r\n                        fallbacks: null,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                    },\r\n                    scene.getEngine()\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <GridMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        this._activeEffect.setFloat(\"visibility\", mesh.visibility);\r\n\r\n        // Matrices\r\n        if (!defines.INSTANCES || defines.THIN_INSTANCE) {\r\n            this.bindOnlyWorldMatrix(world);\r\n        }\r\n        this.bindView(effect);\r\n        this.bindViewProjection(effect);\r\n\r\n        // Uniforms\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            this._activeEffect.setColor3(\"mainColor\", this.mainColor);\r\n            this._activeEffect.setColor3(\"lineColor\", this.lineColor);\r\n\r\n            this._activeEffect.setVector3(\"gridOffset\", this.gridOffset);\r\n\r\n            this._gridControl.x = this.gridRatio;\r\n            this._gridControl.y = Math.round(this.majorUnitFrequency);\r\n            this._gridControl.z = this.minorUnitVisibility;\r\n            this._gridControl.w = this.opacity;\r\n            this._activeEffect.setVector4(\"gridControl\", this._gridControl);\r\n\r\n            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                this._activeEffect.setTexture(\"opacitySampler\", this._opacityTexture);\r\n                this._activeEffect.setFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\r\n                this._activeEffect.setMatrix(\"opacityMatrix\", this._opacityTexture.getTextureMatrix());\r\n            }\r\n\r\n            // Clip plane\r\n            BindClipPlane(effect, this, scene);\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n        }\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Dispose the material and its associated resources.\r\n     * @param forceDisposeEffect will also dispose the used effect when true\r\n     */\r\n    public override dispose(forceDisposeEffect?: boolean): void {\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public override clone(name: string): GridMaterial {\r\n        return SerializationHelper.Clone(() => new GridMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.GridMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"GridMaterial\";\r\n    }\r\n\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): GridMaterial {\r\n        return SerializationHelper.Parse(() => new GridMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GridMaterial\", GridMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"lavaPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;varying vec3 vPositionW;uniform float time;uniform float speed;uniform float movingSpeed;uniform vec3 fogColor;uniform sampler2D noiseTexture;uniform float fogDensity;varying float noise;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0]\n#include<__decl__lightFragment>[1]\n#include<__decl__lightFragment>[2]\n#include<__decl__lightFragment>[3]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nfloat random( vec3 scale,float seed ){return fract( sin( dot( gl_FragCoord.xyz+seed,scale ) )*43758.5453+seed ) ;}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef DIFFUSE\nvec4 noiseTex=texture2D( noiseTexture,vDiffuseUV );vec2 T1=vDiffuseUV+vec2( 1.5,-1.5 )*time *0.02;vec2 T2=vDiffuseUV+vec2( -0.5,2.0 )*time*0.01*speed;T1.x+=noiseTex.x*2.0;T1.y+=noiseTex.y*2.0;T2.x-=noiseTex.y*0.2+time*0.001*movingSpeed;T2.y+=noiseTex.z*0.2+time*0.002*movingSpeed;float p=texture2D( noiseTexture,T1*3.0 ).a;vec4 lavaColor=texture2D( diffuseSampler,T2*4.0);vec4 temp=lavaColor*( vec4( p,p,p,p )*2. )+( lavaColor*lavaColor-0.1 );baseColor=temp;float depth=gl_FragCoord.z*4.0;const float LOG2=1.442695;float fogFactor=exp2(-fogDensity*fogDensity*depth*depth*LOG2 );fogFactor=1.0-clamp( fogFactor,0.0,1.0 );baseColor=mix( baseColor,vec4( fogColor,baseColor.w ),fogFactor );diffuseColor=baseColor.rgb;\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#ifdef UNLIT\nvec3 diffuseBase=vec3(1.,1.,1.);\n#else\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;\n#include<lightFragment>[0]\n#include<lightFragment>[1]\n#include<lightFragment>[2]\n#include<lightFragment>[3]\n#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;vec4 color=vec4(finalDiffuse,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const lavaPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\n\nconst name = \"lavaVertexShader\";\nconst shader = `precision highp float;uniform float time;uniform float lowFrequencySpeed;varying float noise;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n/* NOISE FUNCTIONS */\nvec3 mod289(vec3 x)\n{return x-floor(x*(1.0/289.0))*289.0;}\nvec4 mod289(vec4 x)\n{return x-floor(x*(1.0/289.0))*289.0;}\nvec4 permute(vec4 x)\n{return mod289(((x*34.0)+1.0)*x);}\nvec4 taylorInvSqrt(vec4 r)\n{return 1.79284291400159-0.85373472095314*r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat pnoise(vec3 P,vec3 rep)\n{vec3 Pi0=mod(floor(P),rep); \nvec3 Pi1=mod(Pi0+vec3(1.0),rep); \nPi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P); \nvec3 Pf1=Pf0-vec3(1.0); \nvec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}\n/* END FUNCTION */\nfloat turbulence( vec3 p ) {float w=100.0;float t=-.5;for (float f=1.0 ; f<=10.0 ; f++ ){float power=pow( 2.0,f );t+=abs( pnoise( vec3( power*p ),vec3( 10.0,10.0,10.0 ) )/power );}\nreturn t;}\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#ifdef VERTEXCOLOR\nvec4 colorUpdated=color;\n#endif\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\n#ifdef NORMAL\nnoise=10.0* -.10*turbulence( .5*normal+time*1.15 );float b=lowFrequencySpeed*5.0*pnoise( 0.05*position +vec3(time*1.025),vec3( 100.0 ) );float displacement=- 1.5*noise+b;vec3 newPosition=position+normal*displacement;gl_Position=viewProjection*finalWorld*vec4( newPosition,1.0 );vec4 worldPos=finalWorld*vec4(newPosition,1.0);vPositionW=vec3(worldPos);vNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x==0.)\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}\nelse\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#include<logDepthVertex>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const lavaVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./lava.fragment\";\r\nimport \"./lava.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass LavaMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public LIGHT0 = false;\r\n    public LIGHT1 = false;\r\n    public LIGHT2 = false;\r\n    public LIGHT3 = false;\r\n    public SPOTLIGHT0 = false;\r\n    public SPOTLIGHT1 = false;\r\n    public SPOTLIGHT2 = false;\r\n    public SPOTLIGHT3 = false;\r\n    public HEMILIGHT0 = false;\r\n    public HEMILIGHT1 = false;\r\n    public HEMILIGHT2 = false;\r\n    public HEMILIGHT3 = false;\r\n    public DIRLIGHT0 = false;\r\n    public DIRLIGHT1 = false;\r\n    public DIRLIGHT2 = false;\r\n    public DIRLIGHT3 = false;\r\n    public POINTLIGHT0 = false;\r\n    public POINTLIGHT1 = false;\r\n    public POINTLIGHT2 = false;\r\n    public POINTLIGHT3 = false;\r\n    public SHADOW0 = false;\r\n    public SHADOW1 = false;\r\n    public SHADOW2 = false;\r\n    public SHADOW3 = false;\r\n    public SHADOWS = false;\r\n    public SHADOWESM0 = false;\r\n    public SHADOWESM1 = false;\r\n    public SHADOWESM2 = false;\r\n    public SHADOWESM3 = false;\r\n    public SHADOWPOISSON0 = false;\r\n    public SHADOWPOISSON1 = false;\r\n    public SHADOWPOISSON2 = false;\r\n    public SHADOWPOISSON3 = false;\r\n    public SHADOWPCF0 = false;\r\n    public SHADOWPCF1 = false;\r\n    public SHADOWPCF2 = false;\r\n    public SHADOWPCF3 = false;\r\n    public SHADOWPCSS0 = false;\r\n    public SHADOWPCSS1 = false;\r\n    public SHADOWPCSS2 = false;\r\n    public SHADOWPCSS3 = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public UNLIT = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public AREALIGHTSUPPORTED = true;\r\n    public AREALIGHTNOROUGHTNESS = true;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class LavaMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsTexture()\r\n    public noiseTexture: BaseTexture;\r\n\r\n    @serializeAsColor3()\r\n    public fogColor: Color3;\r\n\r\n    @serialize()\r\n    public speed: number = 1;\r\n\r\n    @serialize()\r\n    public movingSpeed: number = 1;\r\n\r\n    @serialize()\r\n    public lowFrequencySpeed: number = 1;\r\n\r\n    @serialize()\r\n    public fogDensity: number = 0.15;\r\n\r\n    private _lastTime: number = 0;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"unlit\")\r\n    private _unlit = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public unlit: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    private _scaledDiffuse = new Color3();\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public override needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public override needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public override getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new LavaMaterialDefines();\r\n        }\r\n\r\n        const defines = <LavaMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = true;\r\n\r\n        PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"lava\";\r\n            const join = defines.toString();\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n                \"logarithmicDepthConstant\",\r\n                \"time\",\r\n                \"speed\",\r\n                \"movingSpeed\",\r\n                \"fogColor\",\r\n                \"fogDensity\",\r\n                \"lowFrequencySpeed\",\r\n            ];\r\n            AddClipPlaneUniforms(uniforms);\r\n\r\n            const samplers = [\"diffuseSampler\", \"noiseTexture\", \"areaLightsLTC1Sampler\", \"areaLightsLTC2Sampler\"];\r\n            const uniformBuffers: string[] = [];\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n\r\n        // Check if Area Lights have LTC texture.\r\n        if (defines[\"AREALIGHTUSED\"]) {\r\n            for (let index = 0; index < mesh.lightSources.length; index++) {\r\n                if (!mesh.lightSources[index]._isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <LavaMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        defines.UNLIT = this._unlit;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this.diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this.diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this.diffuseTexture.coordinatesIndex, this.diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this.diffuseTexture.getTextureMatrix());\r\n            }\r\n\r\n            if (this.noiseTexture) {\r\n                this._activeEffect.setTexture(\"noiseTexture\", this.noiseTexture);\r\n            }\r\n\r\n            // Clip plane\r\n            BindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this._scaledDiffuse, this.alpha * mesh.visibility);\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._lastTime += scene.getEngine().getDeltaTime();\r\n        this._activeEffect.setFloat(\"time\", (this._lastTime * this.speed) / 1000);\r\n\r\n        if (!this.fogColor) {\r\n            this.fogColor = Color3.Black();\r\n        }\r\n        this._activeEffect.setColor3(\"fogColor\", this.fogColor);\r\n        this._activeEffect.setFloat(\"fogDensity\", this.fogDensity);\r\n\r\n        this._activeEffect.setFloat(\"lowFrequencySpeed\", this.lowFrequencySpeed);\r\n        this._activeEffect.setFloat(\"movingSpeed\", this.movingSpeed);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public override getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0) {\r\n            results.push(this.diffuseTexture);\r\n        }\r\n\r\n        if (this.noiseTexture && this.noiseTexture.animations && this.noiseTexture.animations.length > 0) {\r\n            results.push(this.noiseTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public override getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this.diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.diffuseTexture) {\r\n            this.diffuseTexture.dispose();\r\n        }\r\n        if (this.noiseTexture) {\r\n            this.noiseTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public override clone(name: string): LavaMaterial {\r\n        return SerializationHelper.Clone(() => new LavaMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.LavaMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"LavaMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): LavaMaterial {\r\n        return SerializationHelper.Parse(() => new LavaMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.LavaMaterial\", LavaMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"mixPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#ifdef DIFFUSE\nvarying vec2 vTextureUV;uniform sampler2D mixMap1Sampler;uniform vec2 vTextureInfos;\n#ifdef MIXMAP2\nuniform sampler2D mixMap2Sampler;\n#endif\nuniform sampler2D diffuse1Sampler;uniform sampler2D diffuse2Sampler;uniform sampler2D diffuse3Sampler;uniform sampler2D diffuse4Sampler;uniform vec2 diffuse1Infos;uniform vec2 diffuse2Infos;uniform vec2 diffuse3Infos;uniform vec2 diffuse4Infos;\n#ifdef MIXMAP2\nuniform sampler2D diffuse5Sampler;uniform sampler2D diffuse6Sampler;uniform sampler2D diffuse7Sampler;uniform sampler2D diffuse8Sampler;uniform vec2 diffuse5Infos;uniform vec2 diffuse6Infos;uniform vec2 diffuse7Infos;uniform vec2 diffuse8Infos;\n#endif\n#endif\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 finalMixColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;\n#ifdef MIXMAP2\nvec4 mixColor2=vec4(1.,1.,1.,1.);\n#endif\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;vec3 specularColor=vSpecularColor.rgb;\n#else\nfloat glossiness=0.;\n#endif\nfloat alpha=vDiffuseColor.a;\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#ifdef DIFFUSE\nvec4 mixColor=texture2D(mixMap1Sampler,vTextureUV);\n#include<depthPrePass>\nmixColor.rgb*=vTextureInfos.y;vec4 diffuse1Color=texture2D(diffuse1Sampler,vTextureUV*diffuse1Infos);vec4 diffuse2Color=texture2D(diffuse2Sampler,vTextureUV*diffuse2Infos);vec4 diffuse3Color=texture2D(diffuse3Sampler,vTextureUV*diffuse3Infos);vec4 diffuse4Color=texture2D(diffuse4Sampler,vTextureUV*diffuse4Infos);diffuse1Color.rgb*=mixColor.r;diffuse2Color.rgb=mix(diffuse1Color.rgb,diffuse2Color.rgb,mixColor.g);diffuse3Color.rgb=mix(diffuse2Color.rgb,diffuse3Color.rgb,mixColor.b);finalMixColor.rgb=mix(diffuse3Color.rgb,diffuse4Color.rgb,1.0-mixColor.a);\n#ifdef MIXMAP2\nmixColor=texture2D(mixMap2Sampler,vTextureUV);mixColor.rgb*=vTextureInfos.y;vec4 diffuse5Color=texture2D(diffuse5Sampler,vTextureUV*diffuse5Infos);vec4 diffuse6Color=texture2D(diffuse6Sampler,vTextureUV*diffuse6Infos);vec4 diffuse7Color=texture2D(diffuse7Sampler,vTextureUV*diffuse7Infos);vec4 diffuse8Color=texture2D(diffuse8Sampler,vTextureUV*diffuse8Infos);diffuse5Color.rgb=mix(finalMixColor.rgb,diffuse5Color.rgb,mixColor.r);diffuse6Color.rgb=mix(diffuse5Color.rgb,diffuse6Color.rgb,mixColor.g);diffuse7Color.rgb=mix(diffuse6Color.rgb,diffuse7Color.rgb,mixColor.b);finalMixColor.rgb=mix(diffuse7Color.rgb,diffuse8Color.rgb,1.0-mixColor.a);\n#endif\n#endif\n#ifdef VERTEXCOLOR\nfinalMixColor.rgb*=vColor.rgb;\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float aggShadow=0.;float numLights=0.;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor*finalMixColor.rgb,0.0,1.0);vec4 color=vec4(finalDiffuse+finalSpecular,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const mixPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\n\nconst name = \"mixVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vTextureUV;uniform mat4 textureMatrix;uniform vec2 vTextureInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#ifdef VERTEXCOLOR\nvec4 colorUpdated=color;\n#endif\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vTextureInfos.x==0.)\n{vTextureUV=vec2(textureMatrix*vec4(uv,1.0,0.0));}\nelse\n{vTextureUV=vec2(textureMatrix*vec4(uv2,1.0,0.0));}\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const mixVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./mix.fragment\";\r\nimport \"./mix.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass MixMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public SPECULARTERM = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public MIXMAP2 = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class MixMaterial extends PushMaterial {\r\n    /**\r\n     * Mix textures\r\n     */\r\n\r\n    @serializeAsTexture(\"mixTexture1\")\r\n    private _mixTexture1: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public mixTexture1: BaseTexture;\r\n\r\n    @serializeAsTexture(\"mixTexture2\")\r\n    private _mixTexture2: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public mixTexture2: BaseTexture;\r\n\r\n    /**\r\n     * Diffuse textures\r\n     */\r\n\r\n    @serializeAsTexture(\"diffuseTexture1\")\r\n    private _diffuseTexture1: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture1: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture2\")\r\n    private _diffuseTexture2: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture2: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture3\")\r\n    private _diffuseTexture3: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture3: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture4\")\r\n    private _diffuseTexture4: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture4: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture1\")\r\n    private _diffuseTexture5: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture5: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture2\")\r\n    private _diffuseTexture6: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture6: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture3\")\r\n    private _diffuseTexture7: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture7: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture4\")\r\n    private _diffuseTexture8: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture8: Texture;\r\n\r\n    /**\r\n     * Uniforms\r\n     */\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serializeAsColor3()\r\n    public specularColor = new Color3(0, 0, 0);\r\n\r\n    @serialize()\r\n    public specularPower = 64;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public override needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public override needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public override getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new MixMaterialDefines();\r\n        }\r\n\r\n        const defines = <MixMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (!this._mixTexture1 || !this._mixTexture1.isReady()) {\r\n                return false;\r\n            }\r\n\r\n            defines._needUVs = true;\r\n\r\n            if (MaterialFlags.DiffuseTextureEnabled) {\r\n                if (!this._diffuseTexture1 || !this._diffuseTexture1.isReady()) {\r\n                    return false;\r\n                }\r\n\r\n                defines.DIFFUSE = true;\r\n\r\n                if (!this._diffuseTexture2 || !this._diffuseTexture2.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this._diffuseTexture3 || !this._diffuseTexture3.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this._diffuseTexture4 || !this._diffuseTexture4.isReady()) {\r\n                    return false;\r\n                }\r\n\r\n                if (this._mixTexture2) {\r\n                    if (!this._mixTexture2.isReady()) {\r\n                        return false;\r\n                    }\r\n\r\n                    defines.MIXMAP2 = true;\r\n\r\n                    if (!this._diffuseTexture5 || !this._diffuseTexture5.isReady()) {\r\n                        return false;\r\n                    }\r\n                    if (!this._diffuseTexture6 || !this._diffuseTexture6.isReady()) {\r\n                        return false;\r\n                    }\r\n                    if (!this._diffuseTexture7 || !this._diffuseTexture7.isReady()) {\r\n                        return false;\r\n                    }\r\n                    if (!this._diffuseTexture8 || !this._diffuseTexture8.isReady()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"mix\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vSpecularColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vTextureInfos\",\r\n                \"mBones\",\r\n                \"textureMatrix\",\r\n                \"logarithmicDepthConstant\",\r\n                \"diffuse1Infos\",\r\n                \"diffuse2Infos\",\r\n                \"diffuse3Infos\",\r\n                \"diffuse4Infos\",\r\n                \"diffuse5Infos\",\r\n                \"diffuse6Infos\",\r\n                \"diffuse7Infos\",\r\n                \"diffuse8Infos\",\r\n            ];\r\n            const samplers = [\r\n                \"mixMap1Sampler\",\r\n                \"mixMap2Sampler\",\r\n                \"diffuse1Sampler\",\r\n                \"diffuse2Sampler\",\r\n                \"diffuse3Sampler\",\r\n                \"diffuse4Sampler\",\r\n                \"diffuse5Sampler\",\r\n                \"diffuse6Sampler\",\r\n                \"diffuse7Sampler\",\r\n                \"diffuse8Sampler\",\r\n            ];\r\n\r\n            const uniformBuffers: string[] = [];\r\n\r\n            AddClipPlaneUniforms(uniforms);\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <MixMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this._mixTexture1) {\r\n                this._activeEffect.setTexture(\"mixMap1Sampler\", this._mixTexture1);\r\n                this._activeEffect.setFloat2(\"vTextureInfos\", this._mixTexture1.coordinatesIndex, this._mixTexture1.level);\r\n                this._activeEffect.setMatrix(\"textureMatrix\", this._mixTexture1.getTextureMatrix());\r\n\r\n                if (MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (this._diffuseTexture1) {\r\n                        this._activeEffect.setTexture(\"diffuse1Sampler\", this._diffuseTexture1);\r\n                        this._activeEffect.setFloat2(\"diffuse1Infos\", this._diffuseTexture1.uScale, this._diffuseTexture1.vScale);\r\n                    }\r\n                    if (this._diffuseTexture2) {\r\n                        this._activeEffect.setTexture(\"diffuse2Sampler\", this._diffuseTexture2);\r\n                        this._activeEffect.setFloat2(\"diffuse2Infos\", this._diffuseTexture2.uScale, this._diffuseTexture2.vScale);\r\n                    }\r\n                    if (this._diffuseTexture3) {\r\n                        this._activeEffect.setTexture(\"diffuse3Sampler\", this._diffuseTexture3);\r\n                        this._activeEffect.setFloat2(\"diffuse3Infos\", this._diffuseTexture3.uScale, this._diffuseTexture3.vScale);\r\n                    }\r\n                    if (this._diffuseTexture4) {\r\n                        this._activeEffect.setTexture(\"diffuse4Sampler\", this._diffuseTexture4);\r\n                        this._activeEffect.setFloat2(\"diffuse4Infos\", this._diffuseTexture4.uScale, this._diffuseTexture4.vScale);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this._mixTexture2) {\r\n                this._activeEffect.setTexture(\"mixMap2Sampler\", this._mixTexture2);\r\n\r\n                if (MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (this._diffuseTexture5) {\r\n                        this._activeEffect.setTexture(\"diffuse5Sampler\", this._diffuseTexture5);\r\n                        this._activeEffect.setFloat2(\"diffuse5Infos\", this._diffuseTexture5.uScale, this._diffuseTexture5.vScale);\r\n                    }\r\n                    if (this._diffuseTexture6) {\r\n                        this._activeEffect.setTexture(\"diffuse6Sampler\", this._diffuseTexture6);\r\n                        this._activeEffect.setFloat2(\"diffuse6Infos\", this._diffuseTexture6.uScale, this._diffuseTexture6.vScale);\r\n                    }\r\n                    if (this._diffuseTexture7) {\r\n                        this._activeEffect.setTexture(\"diffuse7Sampler\", this._diffuseTexture7);\r\n                        this._activeEffect.setFloat2(\"diffuse7Infos\", this._diffuseTexture7.uScale, this._diffuseTexture7.vScale);\r\n                    }\r\n                    if (this._diffuseTexture8) {\r\n                        this._activeEffect.setTexture(\"diffuse8Sampler\", this._diffuseTexture8);\r\n                        this._activeEffect.setFloat2(\"diffuse8Infos\", this._diffuseTexture8.uScale, this._diffuseTexture8.vScale);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Clip plane\r\n            BindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            this._activeEffect.setColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public override getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this._mixTexture1 && this._mixTexture1.animations && this._mixTexture1.animations.length > 0) {\r\n            results.push(this._mixTexture1);\r\n        }\r\n\r\n        if (this._mixTexture2 && this._mixTexture2.animations && this._mixTexture2.animations.length > 0) {\r\n            results.push(this._mixTexture2);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public override getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        // Mix map 1\r\n        if (this._mixTexture1) {\r\n            activeTextures.push(this._mixTexture1);\r\n        }\r\n\r\n        if (this._diffuseTexture1) {\r\n            activeTextures.push(this._diffuseTexture1);\r\n        }\r\n\r\n        if (this._diffuseTexture2) {\r\n            activeTextures.push(this._diffuseTexture2);\r\n        }\r\n\r\n        if (this._diffuseTexture3) {\r\n            activeTextures.push(this._diffuseTexture3);\r\n        }\r\n\r\n        if (this._diffuseTexture4) {\r\n            activeTextures.push(this._diffuseTexture4);\r\n        }\r\n\r\n        // Mix map 2\r\n        if (this._mixTexture2) {\r\n            activeTextures.push(this._mixTexture2);\r\n        }\r\n\r\n        if (this._diffuseTexture5) {\r\n            activeTextures.push(this._diffuseTexture5);\r\n        }\r\n\r\n        if (this._diffuseTexture6) {\r\n            activeTextures.push(this._diffuseTexture6);\r\n        }\r\n\r\n        if (this._diffuseTexture7) {\r\n            activeTextures.push(this._diffuseTexture7);\r\n        }\r\n\r\n        if (this._diffuseTexture8) {\r\n            activeTextures.push(this._diffuseTexture8);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        // Mix map 1\r\n        if (this._mixTexture1 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture1 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture2 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture3 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture4 === texture) {\r\n            return true;\r\n        }\r\n\r\n        // Mix map 2\r\n        if (this._mixTexture2 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture5 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture6 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture7 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture8 === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override dispose(forceDisposeEffect?: boolean): void {\r\n        if (this._mixTexture1) {\r\n            this._mixTexture1.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public override clone(name: string): MixMaterial {\r\n        return SerializationHelper.Clone(() => new MixMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.MixMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"MixMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): MixMaterial {\r\n        return SerializationHelper.Parse(() => new MixMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MixMaterial\", MixMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"normalPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;varying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef LIGHTING\n#include<helperFunctions>\n#include<__decl__lightFragment>[0]\n#include<__decl__lightFragment>[1]\n#include<__decl__lightFragment>[2]\n#include<__decl__lightFragment>[3]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#endif\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV);\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef NORMAL\nbaseColor=mix(baseColor,vec4(vNormalW,1.0),0.5);\n#endif\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#ifdef LIGHTING\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;\n#include<lightFragment>[0]\n#include<lightFragment>[1]\n#include<lightFragment>[2]\n#include<lightFragment>[3]\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;\n#else\nvec3 finalDiffuse= baseColor.rgb;\n#endif\nvec4 color=vec4(finalDiffuse,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const normalPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\n\nconst name = \"normalVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x==0.)\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}\nelse\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const normalVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./normal.fragment\";\r\nimport \"./normal.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass NormalMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public LIGHT0 = false;\r\n    public LIGHT1 = false;\r\n    public LIGHT2 = false;\r\n    public LIGHT3 = false;\r\n    public SPOTLIGHT0 = false;\r\n    public SPOTLIGHT1 = false;\r\n    public SPOTLIGHT2 = false;\r\n    public SPOTLIGHT3 = false;\r\n    public HEMILIGHT0 = false;\r\n    public HEMILIGHT1 = false;\r\n    public HEMILIGHT2 = false;\r\n    public HEMILIGHT3 = false;\r\n    public DIRLIGHT0 = false;\r\n    public DIRLIGHT1 = false;\r\n    public DIRLIGHT2 = false;\r\n    public DIRLIGHT3 = false;\r\n    public POINTLIGHT0 = false;\r\n    public POINTLIGHT1 = false;\r\n    public POINTLIGHT2 = false;\r\n    public POINTLIGHT3 = false;\r\n    public SHADOW0 = false;\r\n    public SHADOW1 = false;\r\n    public SHADOW2 = false;\r\n    public SHADOW3 = false;\r\n    public SHADOWS = false;\r\n    public SHADOWESM0 = false;\r\n    public SHADOWESM1 = false;\r\n    public SHADOWESM2 = false;\r\n    public SHADOWESM3 = false;\r\n    public SHADOWPOISSON0 = false;\r\n    public SHADOWPOISSON1 = false;\r\n    public SHADOWPOISSON2 = false;\r\n    public SHADOWPOISSON3 = false;\r\n    public SHADOWPCF0 = false;\r\n    public SHADOWPCF1 = false;\r\n    public SHADOWPCF2 = false;\r\n    public SHADOWPCF3 = false;\r\n    public SHADOWPCSS0 = false;\r\n    public SHADOWPCSS1 = false;\r\n    public SHADOWPCSS2 = false;\r\n    public SHADOWPCSS3 = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public THIN_INSTANCES = false;\r\n    public LIGHTING = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public AREALIGHTSUPPORTED = true;\r\n    public AREALIGHTNOROUGHTNESS = true;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class NormalMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public override needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public override needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\r\n        return this.needAlphaBlending() || mesh.visibility < 1.0;\r\n    }\r\n\r\n    public override needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public override getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new NormalMaterialDefines();\r\n        }\r\n\r\n        const defines = <NormalMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = true;\r\n        PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false, null, subMesh.getRenderingMesh().hasThinInstances);\r\n\r\n        defines.LIGHTING = !this._disableLighting;\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const shaderName = \"normal\";\r\n            const join = defines.toString();\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n                \"logarithmicDepthConstant\",\r\n            ];\r\n            const samplers = [\"diffuseSampler\", \"areaLightsLTC1Sampler\", \"areaLightsLTC2Sampler\"];\r\n            const uniformBuffers: string[] = [];\r\n\r\n            AddClipPlaneUniforms(uniforms);\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: 4,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: 4 },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n\r\n        // Check if Area Lights have LTC texture.\r\n        if (defines[\"AREALIGHTUSED\"]) {\r\n            for (let index = 0; index < mesh.lightSources.length; index++) {\r\n                if (!mesh.lightSources[index]._isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <NormalMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this.diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this.diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this.diffuseTexture.coordinatesIndex, this.diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this.diffuseTexture.getTextureMatrix());\r\n            }\r\n            // Clip plane\r\n            BindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        // Lights\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public override getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0) {\r\n            results.push(this.diffuseTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public override getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this.diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.diffuseTexture) {\r\n            this.diffuseTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public override clone(name: string): NormalMaterial {\r\n        return SerializationHelper.Clone(() => new NormalMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.NormalMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"NormalMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): NormalMaterial {\r\n        return SerializationHelper.Parse(() => new NormalMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NormalMaterial\", NormalMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/sceneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/sceneUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"shadowOnlyPixelShader\";\nconst shader = `precision highp float;\n#include<__decl__sceneFragment>\nuniform float alpha;uniform vec3 shadowColor;varying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;\n#include<lightFragment>[0..1]\nvec4 color=vec4(shadowColor,(1.0-clamp(shadow,0.,1.))*alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const shadowOnlyPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/sceneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/sceneUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\n\nconst name = \"shadowOnlyVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<__decl__sceneVertex>\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const shadowOnlyVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IShadowLight } from \"core/Lights/shadowLight\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./shadowOnly.fragment\";\r\nimport \"./shadowOnly.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport type { CascadedShadowGenerator } from \"core/Lights/Shadows/cascadedShadowGenerator\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass ShadowOnlyMaterialDefines extends MaterialDefines {\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class ShadowOnlyMaterial extends PushMaterial {\r\n    private _activeLight: IShadowLight;\r\n    private _needAlphaBlending = true;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public shadowColor = Color3.Black();\r\n\r\n    public override needAlphaBlending(): boolean {\r\n        return this._needAlphaBlending;\r\n    }\r\n\r\n    public override needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public override getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    public get activeLight(): IShadowLight {\r\n        return this._activeLight;\r\n    }\r\n\r\n    public set activeLight(light: IShadowLight) {\r\n        this._activeLight = light;\r\n    }\r\n\r\n    private _getFirstShadowLightForMesh(mesh: AbstractMesh): Nullable<IShadowLight> {\r\n        for (const light of mesh.lightSources) {\r\n            if (light.shadowEnabled) {\r\n                return light as IShadowLight;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new ShadowOnlyMaterialDefines();\r\n        }\r\n\r\n        const defines = <ShadowOnlyMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Ensure that active light is the first shadow light\r\n        if (this._activeLight) {\r\n            for (const light of mesh.lightSources) {\r\n                if (light.shadowEnabled) {\r\n                    if (this._activeLight === light) {\r\n                        break; // We are good\r\n                    }\r\n\r\n                    const lightPosition = mesh.lightSources.indexOf(this._activeLight);\r\n\r\n                    if (lightPosition !== -1) {\r\n                        mesh.lightSources.splice(lightPosition, 1);\r\n                        mesh.lightSources.splice(0, 0, this._activeLight);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines);\r\n\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, 1);\r\n\r\n        const shadowGenerator = this._getFirstShadowLightForMesh(mesh)?.getShadowGenerator();\r\n\r\n        this._needAlphaBlending = true;\r\n\r\n        if (shadowGenerator && (shadowGenerator as any).getClassName && (shadowGenerator as any).getClassName() === \"CascadedShadowGenerator\") {\r\n            const csg = shadowGenerator as CascadedShadowGenerator;\r\n\r\n            this._needAlphaBlending = !csg.autoCalcDepthBounds;\r\n        }\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, false, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, 1);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const shaderName = \"shadowOnly\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"alpha\",\r\n                \"shadowColor\",\r\n                \"mBones\",\r\n                \"logarithmicDepthConstant\",\r\n            ];\r\n            const samplers: string[] = [];\r\n\r\n            const uniformBuffers: string[] = [\"Scene\"];\r\n\r\n            AddClipPlaneUniforms(uniforms);\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: 1,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    {\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: 1 },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <ShadowOnlyMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this.bindViewProjection(effect);\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Clip plane\r\n            BindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            this._activeEffect.setFloat(\"alpha\", this.alpha);\r\n            this._activeEffect.setColor3(\"shadowColor\", this.shadowColor);\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        // Lights\r\n        if (scene.lightsEnabled) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, 1);\r\n\r\n            const light = this._getFirstShadowLightForMesh(mesh);\r\n\r\n            if (light) {\r\n                // Make sure the uniforms for this light will be rebound for other materials using this light when rendering the current frame.\r\n                // Indeed, there is an optimization in Light that binds the light uniforms only once per frame for a given light (if using ubo).\r\n                // Doing this way assumes that all uses of this light are the same, meaning all parameters passed to Light._bindLlight\r\n                // are the same, notably useSpecular. However, isReadyForSubMesh (see above) is passing false for this parameter, which may not be\r\n                // the value the other materials may pass.\r\n                light._renderId = -1;\r\n            }\r\n        }\r\n\r\n        // View\r\n        if ((scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) || defines[\"SHADOWCSM0\"]) {\r\n            this.bindView(effect);\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public override clone(name: string): ShadowOnlyMaterial {\r\n        return SerializationHelper.Clone<ShadowOnlyMaterial>(() => new ShadowOnlyMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.ShadowOnlyMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"ShadowOnlyMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): ShadowOnlyMaterial {\r\n        return SerializationHelper.Parse(() => new ShadowOnlyMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ShadowOnlyMaterial\", ShadowOnlyMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"simplePixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;varying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV);\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif \n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;vec4 color=vec4(finalDiffuse,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const simplePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"simpleVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#ifdef VERTEXCOLOR\nvec4 colorUpdated=color;\n#endif\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x==0.)\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}\nelse\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const simpleVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./simple.fragment\";\r\nimport \"./simple.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass SimpleMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public AREALIGHTSUPPORTED = true;\r\n    public AREALIGHTNOROUGHTNESS = true;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class SimpleMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsColor3(\"diffuse\")\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public override needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public override needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public override getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new SimpleMaterialDefines();\r\n        }\r\n\r\n        const defines = <SimpleMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const shaderName = \"simple\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n                \"logarithmicDepthConstant\",\r\n            ];\r\n            const samplers = [\"diffuseSampler\", \"areaLightsLTC1Sampler\", \"areaLightsLTC2Sampler\"];\r\n            const uniformBuffers: string[] = [];\r\n\r\n            AddClipPlaneUniforms(uniforms);\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights - 1 },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n\r\n        // Check if Area Lights have LTC texture.\r\n        if (defines[\"AREALIGHTUSED\"]) {\r\n            for (let index = 0; index < mesh.lightSources.length; index++) {\r\n                if (!mesh.lightSources[index]._isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <SimpleMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this._diffuseTexture.getTextureMatrix());\r\n            }\r\n\r\n            // Clip plane\r\n            BindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        // Lights\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public override getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\r\n            results.push(this._diffuseTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public override getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this.diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override dispose(forceDisposeEffect?: boolean): void {\r\n        if (this._diffuseTexture) {\r\n            this._diffuseTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public override clone(name: string): SimpleMaterial {\r\n        return SerializationHelper.Clone<SimpleMaterial>(() => new SimpleMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.SimpleMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"SimpleMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): SimpleMaterial {\r\n        return SerializationHelper.Parse(() => new SimpleMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SimpleMaterial\", SimpleMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"skyPixelShader\";\nconst shader = `precision highp float;varying vec3 vPositionW;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneFragmentDeclaration>\nuniform vec3 cameraPosition;uniform vec3 cameraOffset;uniform vec3 up;uniform float luminance;uniform float turbidity;uniform float rayleigh;uniform float mieCoefficient;uniform float mieDirectionalG;uniform vec3 sunPosition;\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nconst float e=2.71828182845904523536028747135266249775724709369995957;const float pi=3.141592653589793238462643383279502884197169;const float n=1.0003;const float N=2.545E25;const float pn=0.035;const vec3 lambda=vec3(680E-9,550E-9,450E-9);const vec3 K=vec3(0.686,0.678,0.666);const float v=4.0;const float rayleighZenithLength=8.4E3;const float mieZenithLength=1.25E3;const float EE=1000.0;const float sunAngularDiameterCos=0.999956676946448443553574619906976478926848692873900859324;const float cutoffAngle=pi/1.95;const float steepness=1.5;vec3 totalRayleigh(vec3 lambda)\n{return (8.0*pow(pi,3.0)*pow(pow(n,2.0)-1.0,2.0)*(6.0+3.0*pn))/(3.0*N*pow(lambda,vec3(4.0))*(6.0-7.0*pn));}\nvec3 simplifiedRayleigh()\n{return 0.0005/vec3(94,40,18);}\nfloat rayleighPhase(float cosTheta)\n{ \nreturn (3.0/(16.0*pi))*(1.0+pow(cosTheta,2.0));}\nvec3 totalMie(vec3 lambda,vec3 K,float T)\n{float c=(0.2*T )*10E-18;return 0.434*c*pi*pow((2.0*pi)/lambda,vec3(v-2.0))*K;}\nfloat hgPhase(float cosTheta,float g)\n{return (1.0/(4.0*pi))*((1.0-pow(g,2.0))/pow(1.0-2.0*g*cosTheta+pow(g,2.0),1.5));}\nfloat sunIntensity(float zenithAngleCos)\n{return EE*max(0.0,1.0-exp((-(cutoffAngle-acos(zenithAngleCos))/steepness)));}\nfloat A=0.15;float B=0.50;float C=0.10;float D=0.20;float EEE=0.02;float F=0.30;float W=1000.0;vec3 Uncharted2Tonemap(vec3 x)\n{return ((x*(A*x+C*B)+D*EEE)/(x*(A*x+B)+D*F))-EEE/F;}\n#if DITHER\n#include<helperFunctions>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n/**\n*--------------------------------------------------------------------------------------------------\n* Sky Color\n*--------------------------------------------------------------------------------------------------\n*/\nfloat sunfade=1.0-clamp(1.0-exp((sunPosition.y/450000.0)),0.0,1.0);float rayleighCoefficient=rayleigh-(1.0*(1.0-sunfade));vec3 sunDirection=normalize(sunPosition);float sunE=sunIntensity(dot(sunDirection,up));vec3 betaR=simplifiedRayleigh()*rayleighCoefficient;vec3 betaM=totalMie(lambda,K,turbidity)*mieCoefficient;float zenithAngle=acos(max(0.0,dot(up,normalize(vPositionW-cameraPosition+cameraOffset))));float sR=rayleighZenithLength/(cos(zenithAngle)+0.15*pow(93.885-((zenithAngle*180.0)/pi),-1.253));float sM=mieZenithLength/(cos(zenithAngle)+0.15*pow(93.885-((zenithAngle*180.0)/pi),-1.253));vec3 Fex=exp(-(betaR*sR+betaM*sM));float cosTheta=dot(normalize(vPositionW-cameraPosition),sunDirection);float rPhase=rayleighPhase(cosTheta*0.5+0.5);vec3 betaRTheta=betaR*rPhase;float mPhase=hgPhase(cosTheta,mieDirectionalG);vec3 betaMTheta=betaM*mPhase;vec3 Lin=pow(sunE*((betaRTheta+betaMTheta)/(betaR+betaM))*(1.0-Fex),vec3(1.5));Lin*=mix(vec3(1.0),pow(sunE*((betaRTheta+betaMTheta)/(betaR+betaM))*Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up,sunDirection),5.0),0.0,1.0));vec3 direction=normalize(vPositionW-cameraPosition);float theta=acos(direction.y);float phi=atan(direction.z,direction.x);vec2 uv=vec2(phi,theta)/vec2(2.0*pi,pi)+vec2(0.5,0.0);vec3 L0=vec3(0.1)*Fex;float sundisk=smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosTheta);L0+=(sunE*19000.0*Fex)*sundisk;vec3 whiteScale=1.0/Uncharted2Tonemap(vec3(W));vec3 texColor=(Lin+L0);texColor*=0.04 ;texColor+=vec3(0.0,0.001,0.0025)*0.3;float g_fMaxLuminance=1.0;float fLumScaled=0.1/luminance; \nfloat fLumCompressed=(fLumScaled*(1.0+(fLumScaled/(g_fMaxLuminance*g_fMaxLuminance))))/(1.0+fLumScaled); \nfloat ExposureBias=fLumCompressed;vec3 curr=Uncharted2Tonemap((log2(2.0/pow(luminance,4.0)))*texColor);vec3 retColor=curr*whiteScale;/**\n*--------------------------------------------------------------------------------------------------\n* Sky Color\n*--------------------------------------------------------------------------------------------------\n*/\nfloat alpha=1.0;\n#ifdef VERTEXCOLOR\nretColor.rgb*=vColor.rgb;\n#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#if DITHER\nretColor.rgb+=dither(gl_FragCoord.xy,0.5);\n#endif\nvec4 color=clamp(vec4(retColor.rgb,alpha),0.0,1.0);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const skyPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\n\nconst name = \"skyVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\nuniform mat4 world;uniform mat4 view;uniform mat4 viewProjection;\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<logDepthDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\ngl_Position=viewProjection*world*vec4(position,1.0);vec4 worldPos=world*vec4(position,1.0);vPositionW=vec3(worldPos);\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const skyVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsVector3, serialize } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Vector3, Quaternion } from \"core/Maths/math.vector\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./sky.fragment\";\r\nimport \"./sky.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport { BindFogParameters, BindLogDepth, PrepareDefinesForAttributes, PrepareDefinesForMisc } from \"core/Materials/materialHelper.functions\";\r\n\r\n/** @internal */\r\nclass SkyMaterialDefines extends MaterialDefines {\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public DITHER = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\n/**\r\n * This is the sky material which allows to create dynamic and texture free effects for skyboxes.\r\n * @see https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat\r\n */\r\nexport class SkyMaterial extends PushMaterial {\r\n    /**\r\n     * Defines the overall luminance of sky in interval ]0, 1[.\r\n     */\r\n    @serialize()\r\n    public luminance: number = 1.0;\r\n\r\n    /**\r\n     * Defines the amount (scattering) of haze as opposed to molecules in atmosphere.\r\n     */\r\n    @serialize()\r\n    public turbidity: number = 10.0;\r\n\r\n    /**\r\n     * Defines the sky appearance (light intensity).\r\n     */\r\n    @serialize()\r\n    public rayleigh: number = 2.0;\r\n\r\n    /**\r\n     * Defines the mieCoefficient in interval [0, 0.1] which affects the property .mieDirectionalG.\r\n     */\r\n    @serialize()\r\n    public mieCoefficient: number = 0.005;\r\n\r\n    /**\r\n     * Defines the amount of haze particles following the Mie scattering theory.\r\n     */\r\n    @serialize()\r\n    public mieDirectionalG: number = 0.8;\r\n\r\n    /**\r\n     * Defines the distance of the sun according to the active scene camera.\r\n     */\r\n    @serialize()\r\n    public distance: number = 500;\r\n\r\n    /**\r\n     * Defines the sun inclination, in interval [-0.5, 0.5]. When the inclination is not 0, the sun is said\r\n     * \"inclined\".\r\n     */\r\n    @serialize()\r\n    public inclination: number = 0.49;\r\n\r\n    /**\r\n     * Defines the solar azimuth in interval [0, 1]. The azimuth is the angle in the horizontal plan between\r\n     * an object direction and a reference direction.\r\n     */\r\n    @serialize()\r\n    public azimuth: number = 0.25;\r\n\r\n    /**\r\n     * Defines the sun position in the sky on (x,y,z). If the property .useSunPosition is set to false, then\r\n     * the property is overridden by the inclination and the azimuth and can be read at any moment.\r\n     */\r\n    @serializeAsVector3()\r\n    public sunPosition: Vector3 = new Vector3(0, 100, 0);\r\n\r\n    /**\r\n     * Defines if the sun position should be computed (inclination and azimuth) according to the given\r\n     * .sunPosition property.\r\n     */\r\n    @serialize()\r\n    public useSunPosition: boolean = false;\r\n\r\n    /**\r\n     * Defines an offset vector used to get a horizon offset.\r\n     * @example skyMaterial.cameraOffset.y = camera.globalPosition.y // Set horizon relative to 0 on the Y axis\r\n     */\r\n    @serializeAsVector3()\r\n    public cameraOffset: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Defines the vector the skyMaterial should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())\r\n     */\r\n    @serializeAsVector3()\r\n    public up: Vector3 = Vector3.Up();\r\n\r\n    /**\r\n     * Defines if sky should be dithered.\r\n     */\r\n    @serialize()\r\n    public dithering: boolean = false;\r\n\r\n    // Private members\r\n    private _cameraPosition: Vector3 = Vector3.Zero();\r\n    private _skyOrientation: Quaternion = new Quaternion();\r\n\r\n    /**\r\n     * Instantiates a new sky material.\r\n     * This material allows to create dynamic and texture free\r\n     * effects for skyboxes by taking care of the atmosphere state.\r\n     * @see https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belong to\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public override needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns false as the sky material doesn't need alpha testing.\r\n     */\r\n    public override needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the texture used for alpha test purpose.\r\n     * @returns null as the sky material has no texture.\r\n     */\r\n    public override getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get if the submesh is ready to be used and all its information available.\r\n     * Child classes can use it to update shaders\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new SkyMaterialDefines();\r\n        }\r\n\r\n        const defines = <SkyMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, false, defines);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, false);\r\n\r\n        if (defines.IMAGEPROCESSINGPOSTPROCESS !== scene.imageProcessingConfiguration.applyByPostProcess) {\r\n            defines.markAsMiscDirty();\r\n        }\r\n\r\n        if (defines.DITHER !== this.dithering) {\r\n            defines.markAsMiscDirty();\r\n        }\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n            defines.DITHER = this.dithering;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            const shaderName = \"sky\";\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"viewProjection\",\r\n                \"view\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"logarithmicDepthConstant\",\r\n                \"pointSize\",\r\n                \"luminance\",\r\n                \"turbidity\",\r\n                \"rayleigh\",\r\n                \"mieCoefficient\",\r\n                \"mieDirectionalG\",\r\n                \"sunPosition\",\r\n                \"cameraPosition\",\r\n                \"cameraOffset\",\r\n                \"up\",\r\n            ];\r\n            AddClipPlaneUniforms(uniforms);\r\n            const join = defines.toString();\r\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName, attribs, uniforms, [], join, fallbacks, this.onCompiled, this.onError), defines, this._materialContext);\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <SkyMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            BindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        // Sky\r\n        const camera = scene.activeCamera;\r\n        if (camera) {\r\n            const cameraWorldMatrix = camera.getWorldMatrix();\r\n            this._cameraPosition.x = cameraWorldMatrix.m[12];\r\n            this._cameraPosition.y = cameraWorldMatrix.m[13];\r\n            this._cameraPosition.z = cameraWorldMatrix.m[14];\r\n            this._activeEffect.setVector3(\"cameraPosition\", this._cameraPosition);\r\n        }\r\n\r\n        this._activeEffect.setVector3(\"cameraOffset\", this.cameraOffset);\r\n\r\n        this._activeEffect.setVector3(\"up\", this.up);\r\n\r\n        if (this.luminance > 0) {\r\n            this._activeEffect.setFloat(\"luminance\", this.luminance);\r\n        }\r\n\r\n        this._activeEffect.setFloat(\"turbidity\", this.turbidity);\r\n        this._activeEffect.setFloat(\"rayleigh\", this.rayleigh);\r\n        this._activeEffect.setFloat(\"mieCoefficient\", this.mieCoefficient);\r\n        this._activeEffect.setFloat(\"mieDirectionalG\", this.mieDirectionalG);\r\n\r\n        if (!this.useSunPosition) {\r\n            const theta = Math.PI * (this.inclination - 0.5);\r\n            const phi = 2 * Math.PI * (this.azimuth - 0.5);\r\n\r\n            this.sunPosition.x = this.distance * Math.cos(phi) * Math.cos(theta);\r\n            this.sunPosition.y = this.distance * Math.sin(-theta);\r\n            this.sunPosition.z = this.distance * Math.sin(phi) * Math.cos(theta);\r\n\r\n            Quaternion.FromUnitVectorsToRef(Vector3.UpReadOnly, this.up, this._skyOrientation);\r\n            this.sunPosition.rotateByQuaternionToRef(this._skyOrientation, this.sunPosition);\r\n        }\r\n\r\n        this._activeEffect.setVector3(\"sunPosition\", this.sunPosition);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Get the list of animatables in the material.\r\n     * @returns the list of animatables object used in the material\r\n     */\r\n    public override getAnimatables(): IAnimatable[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     */\r\n    public override dispose(forceDisposeEffect?: boolean): void {\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    public override clone(name: string): SkyMaterial {\r\n        return SerializationHelper.Clone<SkyMaterial>(() => new SkyMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.SkyMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"SkyMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"SkyMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Creates a sky material from parsed material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new sky material\r\n     */\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): SkyMaterial {\r\n        return SerializationHelper.Parse(() => new SkyMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SkyMaterial\", SkyMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"terrainPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#ifdef DIFFUSE\nvarying vec2 vTextureUV;uniform sampler2D textureSampler;uniform vec2 vTextureInfos;uniform sampler2D diffuse1Sampler;uniform sampler2D diffuse2Sampler;uniform sampler2D diffuse3Sampler;uniform vec2 diffuse1Infos;uniform vec2 diffuse2Infos;uniform vec2 diffuse3Infos;\n#endif\n#ifdef BUMP\nuniform sampler2D bump1Sampler;uniform sampler2D bump2Sampler;uniform sampler2D bump3Sampler;\n#endif\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#ifdef BUMP\n#extension GL_OES_standard_derivatives : enable\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv)\n{vec3 dp1=dFdx(p);vec3 dp2=dFdy(p);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 binormal=dp2perp*duv1.y+dp1perp*duv2.y;float invmax=inversesqrt(max(dot(tangent,tangent),dot(binormal,binormal)));return mat3(tangent*invmax,binormal*invmax,normal);}\nvec3 perturbNormal(vec3 viewDir,vec3 mixColor)\n{vec3 bump1Color=texture2D(bump1Sampler,vTextureUV*diffuse1Infos).xyz;vec3 bump2Color=texture2D(bump2Sampler,vTextureUV*diffuse2Infos).xyz;vec3 bump3Color=texture2D(bump3Sampler,vTextureUV*diffuse3Infos).xyz;bump1Color.rgb*=mixColor.r;bump2Color.rgb=mix(bump1Color.rgb,bump2Color.rgb,mixColor.g);vec3 map=mix(bump2Color.rgb,bump3Color.rgb,mixColor.b);map=map*255./127.-128./127.;mat3 TBN=cotangent_frame(vNormalW*vTextureInfos.y,-viewDir,vTextureUV);return normalize(TBN*map);}\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;vec3 specularColor=vSpecularColor.rgb;\n#else\nfloat glossiness=0.;\n#endif\nfloat alpha=vDiffuseColor.a;\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#ifdef DIFFUSE\nbaseColor=texture2D(textureSampler,vTextureUV);\n#if defined(BUMP) && defined(DIFFUSE)\nnormalW=perturbNormal(viewDirectionW,baseColor.rgb);\n#endif\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vTextureInfos.y;vec4 diffuse1Color=texture2D(diffuse1Sampler,vTextureUV*diffuse1Infos);vec4 diffuse2Color=texture2D(diffuse2Sampler,vTextureUV*diffuse2Infos);vec4 diffuse3Color=texture2D(diffuse3Sampler,vTextureUV*diffuse3Infos);diffuse1Color.rgb*=baseColor.r;diffuse2Color.rgb=mix(diffuse1Color.rgb,diffuse2Color.rgb,baseColor.g);baseColor.rgb=mix(diffuse2Color.rgb,diffuse3Color.rgb,baseColor.b);\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float aggShadow=0.;float numLights=0.;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor*baseColor.rgb,0.0,1.0);vec4 color=vec4(finalDiffuse+finalSpecular,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const terrainPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"terrainVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vTextureUV;uniform mat4 textureMatrix;uniform vec2 vTextureInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<logDepthDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#ifdef VERTEXCOLOR\nvec4 colorUpdated=color;\n#endif\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vTextureInfos.x==0.)\n{vTextureUV=vec2(textureMatrix*vec4(uv,1.0,0.0));}\nelse\n{vTextureUV=vec2(textureMatrix*vec4(uv2,1.0,0.0));}\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const terrainVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./terrain.fragment\";\r\nimport \"./terrain.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass TerrainMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public BUMP = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public SPECULARTERM = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public AREALIGHTSUPPORTED = true;\r\n    public AREALIGHTNOROUGHTNESS = true;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class TerrainMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"mixTexture\")\r\n    private _mixTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public mixTexture: BaseTexture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture1\")\r\n    private _diffuseTexture1: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture1: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture2\")\r\n    private _diffuseTexture2: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture2: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture3\")\r\n    private _diffuseTexture3: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture3: Texture;\r\n\r\n    @serializeAsTexture(\"bumpTexture1\")\r\n    private _bumpTexture1: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture1: Texture;\r\n\r\n    @serializeAsTexture(\"bumpTexture2\")\r\n    private _bumpTexture2: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture2: Texture;\r\n\r\n    @serializeAsTexture(\"bumpTexture3\")\r\n    private _bumpTexture3: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture3: Texture;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serializeAsColor3()\r\n    public specularColor = new Color3(0, 0, 0);\r\n\r\n    @serialize()\r\n    public specularPower = 64;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public override needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public override needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public override getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new TerrainMaterialDefines();\r\n        }\r\n\r\n        const defines = <TerrainMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (!this.mixTexture || !this.mixTexture.isReady()) {\r\n                return false;\r\n            }\r\n\r\n            defines._needUVs = true;\r\n\r\n            if (MaterialFlags.DiffuseTextureEnabled) {\r\n                if (!this.diffuseTexture1 || !this.diffuseTexture1.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this.diffuseTexture2 || !this.diffuseTexture2.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this.diffuseTexture3 || !this.diffuseTexture3.isReady()) {\r\n                    return false;\r\n                }\r\n\r\n                defines.DIFFUSE = true;\r\n            }\r\n\r\n            if (this.bumpTexture1 && this.bumpTexture2 && this.bumpTexture3 && MaterialFlags.BumpTextureEnabled) {\r\n                if (!this.bumpTexture1.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this.bumpTexture2.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this.bumpTexture3.isReady()) {\r\n                    return false;\r\n                }\r\n\r\n                defines._needNormals = true;\r\n                defines.BUMP = true;\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"terrain\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vSpecularColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vTextureInfos\",\r\n                \"mBones\",\r\n                \"textureMatrix\",\r\n                \"diffuse1Infos\",\r\n                \"diffuse2Infos\",\r\n                \"diffuse3Infos\",\r\n            ];\r\n            const samplers = [\r\n                \"textureSampler\",\r\n                \"diffuse1Sampler\",\r\n                \"diffuse2Sampler\",\r\n                \"diffuse3Sampler\",\r\n                \"bump1Sampler\",\r\n                \"bump2Sampler\",\r\n                \"bump3Sampler\",\r\n                \"logarithmicDepthConstant\",\r\n                \"areaLightsLTC1Sampler\",\r\n                \"areaLightsLTC2Sampler\",\r\n            ];\r\n\r\n            const uniformBuffers: string[] = [];\r\n\r\n            AddClipPlaneUniforms(uniforms);\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n\r\n        // Check if Area Lights have LTC texture.\r\n        if (defines[\"AREALIGHTUSED\"]) {\r\n            for (let index = 0; index < mesh.lightSources.length; index++) {\r\n                if (!mesh.lightSources[index]._isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <TerrainMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this.mixTexture) {\r\n                this._activeEffect.setTexture(\"textureSampler\", this._mixTexture);\r\n                this._activeEffect.setFloat2(\"vTextureInfos\", this._mixTexture.coordinatesIndex, this._mixTexture.level);\r\n                this._activeEffect.setMatrix(\"textureMatrix\", this._mixTexture.getTextureMatrix());\r\n\r\n                if (MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (this._diffuseTexture1) {\r\n                        this._activeEffect.setTexture(\"diffuse1Sampler\", this._diffuseTexture1);\r\n                        this._activeEffect.setFloat2(\"diffuse1Infos\", this._diffuseTexture1.uScale, this._diffuseTexture1.vScale);\r\n                    }\r\n                    if (this._diffuseTexture2) {\r\n                        this._activeEffect.setTexture(\"diffuse2Sampler\", this._diffuseTexture2);\r\n                        this._activeEffect.setFloat2(\"diffuse2Infos\", this._diffuseTexture2.uScale, this._diffuseTexture2.vScale);\r\n                    }\r\n                    if (this._diffuseTexture3) {\r\n                        this._activeEffect.setTexture(\"diffuse3Sampler\", this._diffuseTexture3);\r\n                        this._activeEffect.setFloat2(\"diffuse3Infos\", this._diffuseTexture3.uScale, this._diffuseTexture3.vScale);\r\n                    }\r\n                }\r\n\r\n                if (MaterialFlags.BumpTextureEnabled && scene.getEngine().getCaps().standardDerivatives) {\r\n                    if (this._bumpTexture1) {\r\n                        this._activeEffect.setTexture(\"bump1Sampler\", this._bumpTexture1);\r\n                    }\r\n                    if (this._bumpTexture2) {\r\n                        this._activeEffect.setTexture(\"bump2Sampler\", this._bumpTexture2);\r\n                    }\r\n                    if (this._bumpTexture3) {\r\n                        this._activeEffect.setTexture(\"bump3Sampler\", this._bumpTexture3);\r\n                    }\r\n                }\r\n            }\r\n            // Clip plane\r\n            BindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            this._activeEffect.setColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public override getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this.mixTexture && this.mixTexture.animations && this.mixTexture.animations.length > 0) {\r\n            results.push(this.mixTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public override getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._mixTexture) {\r\n            activeTextures.push(this._mixTexture);\r\n        }\r\n\r\n        if (this._diffuseTexture1) {\r\n            activeTextures.push(this._diffuseTexture1);\r\n        }\r\n\r\n        if (this._diffuseTexture2) {\r\n            activeTextures.push(this._diffuseTexture2);\r\n        }\r\n\r\n        if (this._diffuseTexture3) {\r\n            activeTextures.push(this._diffuseTexture3);\r\n        }\r\n\r\n        if (this._bumpTexture1) {\r\n            activeTextures.push(this._bumpTexture1);\r\n        }\r\n\r\n        if (this._bumpTexture2) {\r\n            activeTextures.push(this._bumpTexture2);\r\n        }\r\n\r\n        if (this._bumpTexture3) {\r\n            activeTextures.push(this._bumpTexture3);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._mixTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture1 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture2 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture3 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture1 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture2 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture3 === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.mixTexture) {\r\n            this.mixTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public override clone(name: string): TerrainMaterial {\r\n        return SerializationHelper.Clone(() => new TerrainMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.TerrainMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"TerrainMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): TerrainMaterial {\r\n        return SerializationHelper.Parse(() => new TerrainMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TerrainMaterial\", TerrainMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"triplanarPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nvarying vec3 vPositionW;\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#ifdef DIFFUSEX\nvarying vec2 vTextureUVX;uniform sampler2D diffuseSamplerX;\n#ifdef BUMPX\nuniform sampler2D normalSamplerX;\n#endif\n#endif\n#ifdef DIFFUSEY\nvarying vec2 vTextureUVY;uniform sampler2D diffuseSamplerY;\n#ifdef BUMPY\nuniform sampler2D normalSamplerY;\n#endif\n#endif\n#ifdef DIFFUSEZ\nvarying vec2 vTextureUVZ;uniform sampler2D diffuseSamplerZ;\n#ifdef BUMPZ\nuniform sampler2D normalSamplerZ;\n#endif\n#endif\n#ifdef NORMAL\nvarying mat3 tangentSpace;\n#endif\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(0.,0.,0.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef NORMAL\nvec3 normalW=tangentSpace[2];\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\nvec4 baseNormal=vec4(0.0,0.0,0.0,1.0);normalW*=normalW;\n#ifdef DIFFUSEX\nbaseColor+=texture2D(diffuseSamplerX,vTextureUVX)*normalW.x;\n#ifdef BUMPX\nbaseNormal+=texture2D(normalSamplerX,vTextureUVX)*normalW.x;\n#endif\n#endif\n#ifdef DIFFUSEY\nbaseColor+=texture2D(diffuseSamplerY,vTextureUVY)*normalW.y;\n#ifdef BUMPY\nbaseNormal+=texture2D(normalSamplerY,vTextureUVY)*normalW.y;\n#endif\n#endif\n#ifdef DIFFUSEZ\nbaseColor+=texture2D(diffuseSamplerZ,vTextureUVZ)*normalW.z;\n#ifdef BUMPZ\nbaseNormal+=texture2D(normalSamplerZ,vTextureUVZ)*normalW.z;\n#endif\n#endif\n#ifdef NORMAL\nnormalW=normalize((2.0*baseNormal.xyz-1.0)*tangentSpace);\n#endif\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float aggShadow=0.;float numLights=0.;\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;vec3 specularBase=vec3(0.,0.,0.);vec3 specularColor=vSpecularColor.rgb;\n#else\nfloat glossiness=0.;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;vec4 color=vec4(finalDiffuse+finalSpecular,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const triplanarPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"triplanarVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSEX\nvarying vec2 vTextureUVX;\n#endif\n#ifdef DIFFUSEY\nvarying vec2 vTextureUVY;\n#endif\n#ifdef DIFFUSEZ\nvarying vec2 vTextureUVZ;\n#endif\nuniform float tileSize;\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying mat3 tangentSpace;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#ifdef VERTEXCOLOR\nvec4 colorUpdated=color;\n#endif\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef DIFFUSEX\nvTextureUVX=worldPos.zy/tileSize;\n#endif\n#ifdef DIFFUSEY\nvTextureUVY=worldPos.xz/tileSize;\n#endif\n#ifdef DIFFUSEZ\nvTextureUVZ=worldPos.xy/tileSize;\n#endif\n#ifdef NORMAL\nvec3 xtan=vec3(0,0,1);vec3 xbin=vec3(0,1,0);vec3 ytan=vec3(1,0,0);vec3 ybin=vec3(0,0,1);vec3 ztan=vec3(1,0,0);vec3 zbin=vec3(0,1,0);vec3 normalizedNormal=normalize(normal);normalizedNormal*=normalizedNormal;vec3 worldBinormal=normalize(xbin*normalizedNormal.x+ybin*normalizedNormal.y+zbin*normalizedNormal.z);vec3 worldTangent=normalize(xtan*normalizedNormal.x+ytan*normalizedNormal.y+ztan*normalizedNormal.z);mat3 normalWorld=mat3(finalWorld);\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nworldTangent=normalize((normalWorld*worldTangent).xyz);worldBinormal=normalize((normalWorld*worldBinormal).xyz);vec3 worldNormal=normalize((normalWorld*normalize(normal)).xyz);tangentSpace[0]=worldTangent;tangentSpace[1]=worldBinormal;tangentSpace[2]=worldNormal;\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const triplanarVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\n\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./triplanar.fragment\";\r\nimport \"./triplanar.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass TriPlanarMaterialDefines extends MaterialDefines {\r\n    public DIFFUSEX = false;\r\n    public DIFFUSEY = false;\r\n    public DIFFUSEZ = false;\r\n\r\n    public BUMPX = false;\r\n    public BUMPY = false;\r\n    public BUMPZ = false;\r\n\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public SPECULARTERM = false;\r\n    public NORMAL = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public NONUNIFORMSCALING = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public AREALIGHTSUPPORTED = true;\r\n    public AREALIGHTNOROUGHTNESS = true;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class TriPlanarMaterial extends PushMaterial {\r\n    @serializeAsTexture()\r\n    public mixTexture: BaseTexture;\r\n\r\n    @serializeAsTexture(\"diffuseTextureX\")\r\n    private _diffuseTextureX: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTextureX: BaseTexture;\r\n\r\n    @serializeAsTexture(\"diffuseTexturY\")\r\n    private _diffuseTextureY: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTextureY: BaseTexture;\r\n\r\n    @serializeAsTexture(\"diffuseTextureZ\")\r\n    private _diffuseTextureZ: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTextureZ: BaseTexture;\r\n\r\n    @serializeAsTexture(\"normalTextureX\")\r\n    private _normalTextureX: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public normalTextureX: BaseTexture;\r\n\r\n    @serializeAsTexture(\"normalTextureY\")\r\n    private _normalTextureY: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public normalTextureY: BaseTexture;\r\n\r\n    @serializeAsTexture(\"normalTextureZ\")\r\n    private _normalTextureZ: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public normalTextureZ: BaseTexture;\r\n\r\n    @serialize()\r\n    public tileSize: number = 1;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serializeAsColor3()\r\n    public specularColor = new Color3(0.2, 0.2, 0.2);\r\n\r\n    @serialize()\r\n    public specularPower = 64;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public override needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public override needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public override getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new TriPlanarMaterialDefines();\r\n        }\r\n\r\n        const defines = <TriPlanarMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (MaterialFlags.DiffuseTextureEnabled) {\r\n                    const textures = [this.diffuseTextureX, this.diffuseTextureY, this.diffuseTextureZ];\r\n                    const textureDefines = [\"DIFFUSEX\", \"DIFFUSEY\", \"DIFFUSEZ\"];\r\n\r\n                    for (let i = 0; i < textures.length; i++) {\r\n                        if (textures[i]) {\r\n                            if (!textures[i].isReady()) {\r\n                                return false;\r\n                            } else {\r\n                                (<any>defines)[textureDefines[i]] = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (MaterialFlags.BumpTextureEnabled) {\r\n                    const textures = [this.normalTextureX, this.normalTextureY, this.normalTextureZ];\r\n                    const textureDefines = [\"BUMPX\", \"BUMPY\", \"BUMPZ\"];\r\n\r\n                    for (let i = 0; i < textures.length; i++) {\r\n                        if (textures[i]) {\r\n                            if (!textures[i].isReady()) {\r\n                                return false;\r\n                            } else {\r\n                                (<any>defines)[textureDefines[i]] = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"triplanar\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vSpecularColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"mBones\",\r\n                \"tileSize\",\r\n            ];\r\n            const samplers = [\r\n                \"diffuseSamplerX\",\r\n                \"diffuseSamplerY\",\r\n                \"diffuseSamplerZ\",\r\n                \"normalSamplerX\",\r\n                \"normalSamplerY\",\r\n                \"normalSamplerZ\",\r\n                \"logarithmicDepthConstant\",\r\n                \"areaLightsLTC1Sampler\",\r\n                \"areaLightsLTC2Sampler\",\r\n            ];\r\n\r\n            const uniformBuffers: string[] = [];\r\n\r\n            AddClipPlaneUniforms(uniforms);\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n\r\n        // Check if Area Lights have LTC texture.\r\n        if (defines[\"AREALIGHTUSED\"]) {\r\n            for (let index = 0; index < mesh.lightSources.length; index++) {\r\n                if (!mesh.lightSources[index]._isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <TriPlanarMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        this._activeEffect.setFloat(\"tileSize\", this.tileSize);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this.diffuseTextureX) {\r\n                this._activeEffect.setTexture(\"diffuseSamplerX\", this.diffuseTextureX);\r\n            }\r\n            if (this.diffuseTextureY) {\r\n                this._activeEffect.setTexture(\"diffuseSamplerY\", this.diffuseTextureY);\r\n            }\r\n            if (this.diffuseTextureZ) {\r\n                this._activeEffect.setTexture(\"diffuseSamplerZ\", this.diffuseTextureZ);\r\n            }\r\n            if (this.normalTextureX) {\r\n                this._activeEffect.setTexture(\"normalSamplerX\", this.normalTextureX);\r\n            }\r\n            if (this.normalTextureY) {\r\n                this._activeEffect.setTexture(\"normalSamplerY\", this.normalTextureY);\r\n            }\r\n            if (this.normalTextureZ) {\r\n                this._activeEffect.setTexture(\"normalSamplerZ\", this.normalTextureZ);\r\n            }\r\n            // Clip plane\r\n            BindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            this._activeEffect.setColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public override getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this.mixTexture && this.mixTexture.animations && this.mixTexture.animations.length > 0) {\r\n            results.push(this.mixTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public override getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTextureX) {\r\n            activeTextures.push(this._diffuseTextureX);\r\n        }\r\n\r\n        if (this._diffuseTextureY) {\r\n            activeTextures.push(this._diffuseTextureY);\r\n        }\r\n\r\n        if (this._diffuseTextureZ) {\r\n            activeTextures.push(this._diffuseTextureZ);\r\n        }\r\n\r\n        if (this._normalTextureX) {\r\n            activeTextures.push(this._normalTextureX);\r\n        }\r\n\r\n        if (this._normalTextureY) {\r\n            activeTextures.push(this._normalTextureY);\r\n        }\r\n\r\n        if (this._normalTextureZ) {\r\n            activeTextures.push(this._normalTextureZ);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTextureX === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTextureY === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTextureZ === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._normalTextureX === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._normalTextureY === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._normalTextureZ === texture) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public override dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.mixTexture) {\r\n            this.mixTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public override clone(name: string): TriPlanarMaterial {\r\n        return SerializationHelper.Clone(() => new TriPlanarMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.TriPlanarMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"TriPlanarMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): TriPlanarMaterial {\r\n        return SerializationHelper.Parse(() => new TriPlanarMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TriPlanarMaterial\", TriPlanarMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/imageProcessingDeclaration\";\nimport \"core/Shaders/ShadersInclude/imageProcessingFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\n\nconst name = \"waterPixelShader\";\nconst shader = `#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nprecision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#ifdef BUMP\nvarying vec2 vNormalUV;\n#ifdef BUMPSUPERIMPOSE\nvarying vec2 vNormalUV2;\n#endif\nuniform sampler2D normalSampler;uniform vec2 vNormalInfos;\n#endif\nuniform sampler2D refractionSampler;uniform sampler2D reflectionSampler;const float LOG2=1.442695;uniform vec3 cameraPosition;uniform vec4 waterColor;uniform float colorBlendFactor;uniform vec4 waterColor2;uniform float colorBlendFactor2;uniform float bumpHeight;uniform float time;varying vec3 vRefractionMapTexCoord;varying vec3 vReflectionMapTexCoord;\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef BUMP\n#ifdef BUMPSUPERIMPOSE\nbaseColor=0.6*texture2D(normalSampler,vNormalUV)+0.4*texture2D(normalSampler,vec2(vNormalUV2.x,vNormalUV2.y));\n#else\nbaseColor=texture2D(normalSampler,vNormalUV);\n#endif\nvec3 bumpColor=baseColor.rgb;\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\nbaseColor.rgb*=vNormalInfos.y;\n#else\nvec3 bumpColor=vec3(1.0);\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef NORMAL\nvec2 perturbation=bumpHeight*(baseColor.rg-0.5);\n#ifdef BUMPAFFECTSREFLECTION\nvec3 normalW=normalize(vNormalW+vec3(perturbation.x*8.0,0.0,perturbation.y*8.0));if (normalW.y<0.0) {normalW.y=-normalW.y;}\n#else\nvec3 normalW=normalize(vNormalW);\n#endif\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);vec2 perturbation=bumpHeight*(vec2(1.0,1.0)-0.5);\n#endif\n#ifdef FRESNELSEPARATE\n#ifdef REFLECTION\nvec2 projectedRefractionTexCoords=clamp(vRefractionMapTexCoord.xy/vRefractionMapTexCoord.z+perturbation*0.5,0.0,1.0);vec4 refractiveColor=texture2D(refractionSampler,projectedRefractionTexCoords);\n#ifdef IS_REFRACTION_LINEAR\nrefractiveColor.rgb=toGammaSpace(refractiveColor.rgb);\n#endif\nvec2 projectedReflectionTexCoords=clamp(vec2(\nvReflectionMapTexCoord.x/vReflectionMapTexCoord.z+perturbation.x*0.3,\nvReflectionMapTexCoord.y/vReflectionMapTexCoord.z+perturbation.y\n),0.0,1.0);vec4 reflectiveColor=texture2D(reflectionSampler,projectedReflectionTexCoords);\n#ifdef IS_REFLECTION_LINEAR\nreflectiveColor.rgb=toGammaSpace(reflectiveColor.rgb);\n#endif\nvec3 upVector=vec3(0.0,1.0,0.0);float fresnelTerm=clamp(abs(pow(dot(viewDirectionW,upVector),3.0)),0.05,0.65);float IfresnelTerm=1.0-fresnelTerm;refractiveColor=colorBlendFactor*waterColor+(1.0-colorBlendFactor)*refractiveColor;reflectiveColor=IfresnelTerm*colorBlendFactor2*waterColor+(1.0-colorBlendFactor2*IfresnelTerm)*reflectiveColor;vec4 combinedColor=refractiveColor*fresnelTerm+reflectiveColor*IfresnelTerm;baseColor=combinedColor;\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float aggShadow=0.;float numLights=0.;\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;vec3 specularBase=vec3(0.,0.,0.);vec3 specularColor=vSpecularColor.rgb;\n#else\nfloat glossiness=0.;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\nvec3 finalDiffuse=clamp(baseColor.rgb,0.0,1.0);\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\n#else \n#ifdef REFLECTION\nvec2 projectedRefractionTexCoords=clamp(vRefractionMapTexCoord.xy/vRefractionMapTexCoord.z+perturbation,0.0,1.0);vec4 refractiveColor=texture2D(refractionSampler,projectedRefractionTexCoords);\n#ifdef IS_REFRACTION_LINEAR\nrefractiveColor.rgb=toGammaSpace(refractiveColor.rgb);\n#endif\nvec2 projectedReflectionTexCoords=clamp(vReflectionMapTexCoord.xy/vReflectionMapTexCoord.z+perturbation,0.0,1.0);vec4 reflectiveColor=texture2D(reflectionSampler,projectedReflectionTexCoords);\n#ifdef IS_REFLECTION_LINEAR\nreflectiveColor.rgb=toGammaSpace(reflectiveColor.rgb);\n#endif\nvec3 upVector=vec3(0.0,1.0,0.0);float fresnelTerm=max(dot(viewDirectionW,upVector),0.0);vec4 combinedColor=refractiveColor*fresnelTerm+reflectiveColor*(1.0-fresnelTerm);baseColor=colorBlendFactor*waterColor+(1.0-colorBlendFactor)*combinedColor;\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float aggShadow=0.;float numLights=0.;\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;vec3 specularBase=vec3(0.,0.,0.);vec3 specularColor=vSpecularColor.rgb;\n#else\nfloat glossiness=0.;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\nvec3 finalDiffuse=clamp(baseColor.rgb,0.0,1.0);\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\n#endif\nvec4 color=vec4(finalDiffuse+finalSpecular,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor.rgb=toLinearSpace(color.rgb);\n#elif defined(IMAGEPROCESSING)\ncolor.rgb=toLinearSpace(color.rgb);color=applyImageProcessing(color);\n#endif\ngl_FragColor=color;\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const waterPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\n\nconst name = \"waterVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef BUMP\nvarying vec2 vNormalUV;\n#ifdef BUMPSUPERIMPOSE\nvarying vec2 vNormalUV2;\n#endif\nuniform mat4 normalMatrix;uniform vec2 vNormalInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<logDepthDeclaration>\nuniform mat4 reflectionViewProjection;uniform vec2 windDirection;uniform float waveLength;uniform float time;uniform float windForce;uniform float waveHeight;uniform float waveSpeed;uniform float waveCount;varying vec3 vRefractionMapTexCoord;varying vec3 vReflectionMapTexCoord;\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#ifdef VERTEXCOLOR\nvec4 colorUpdated=color;\n#endif\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);vPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef BUMP\nif (vNormalInfos.x==0.)\n{vNormalUV=vec2(normalMatrix*vec4((uv*1.0)/waveLength+time*windForce*windDirection,1.0,0.0));\n#ifdef BUMPSUPERIMPOSE\nvNormalUV2=vec2(normalMatrix*vec4((uv*0.721)/waveLength+time*1.2*windForce*windDirection,1.0,0.0));\n#endif\n}\nelse\n{vNormalUV=vec2(normalMatrix*vec4((uv2*1.0)/waveLength+time*windForce*windDirection ,1.0,0.0));\n#ifdef BUMPSUPERIMPOSE\nvNormalUV2=vec2(normalMatrix*vec4((uv2*0.721)/waveLength+time*1.2*windForce*windDirection ,1.0,0.0));\n#endif\n}\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\nfloat finalWaveCount=1.0/(waveCount*0.5);\n#ifdef USE_WORLD_COORDINATES\nvec3 p=worldPos.xyz;\n#else\nvec3 p=position;\n#endif\nfloat newY=(sin(((p.x/finalWaveCount)+time*waveSpeed))*waveHeight*windDirection.x*5.0)\n+ (cos(((p.z/finalWaveCount)+ time*waveSpeed))*waveHeight*windDirection.y*5.0);p.y+=abs(newY);\n#ifdef USE_WORLD_COORDINATES\ngl_Position=viewProjection*vec4(p,1.0);\n#else\ngl_Position=viewProjection*finalWorld*vec4(p,1.0);\n#endif\n#ifdef REFLECTION\nvRefractionMapTexCoord.x=0.5*(gl_Position.w+gl_Position.x);vRefractionMapTexCoord.y=0.5*(gl_Position.w+gl_Position.y);vRefractionMapTexCoord.z=gl_Position.w;worldPos=reflectionViewProjection*finalWorld*vec4(position,1.0);vReflectionMapTexCoord.x=0.5*(worldPos.w+worldPos.x);vReflectionMapTexCoord.y=0.5*(worldPos.w+worldPos.y);vReflectionMapTexCoord.z=worldPos.w;\n#endif\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const waterVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsVector2, serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport { Matrix, Vector2, Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Plane } from \"core/Maths/math.plane\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { SmartArray } from \"core/Misc/smartArray\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { RenderTargetTexture } from \"core/Materials/Textures/renderTargetTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport type { IImageProcessingConfigurationDefines } from \"core/Materials/imageProcessingConfiguration.defines\";\r\nimport { ImageProcessingConfiguration } from \"core/Materials/imageProcessingConfiguration\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./water.fragment\";\r\nimport \"./water.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { CreateGround } from \"core/Meshes/Builders/groundBuilder\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nimport \"core/Rendering/boundingBoxRenderer\";\r\n\r\nclass WaterMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {\r\n    public BUMP = false;\r\n    public REFLECTION = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public SPECULARTERM = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public USE_REVERSE_DEPTHBUFFER = false;\r\n    public FRESNELSEPARATE = false;\r\n    public BUMPSUPERIMPOSE = false;\r\n    public BUMPAFFECTSREFLECTION = false;\r\n    public USE_WORLD_COORDINATES = false;\r\n\r\n    public IMAGEPROCESSING = false;\r\n    public VIGNETTE = false;\r\n    public VIGNETTEBLENDMODEMULTIPLY = false;\r\n    public VIGNETTEBLENDMODEOPAQUE = false;\r\n    public TONEMAPPING = 0;\r\n    public CONTRAST = false;\r\n    public EXPOSURE = false;\r\n    public COLORCURVES = false;\r\n    public COLORGRADING = false;\r\n    public COLORGRADING3D = false;\r\n    public SAMPLER3DGREENDEPTH = false;\r\n    public SAMPLER3DBGRMAP = false;\r\n    public DITHER = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class WaterMaterial extends PushMaterial {\r\n    /*\r\n     * Public members\r\n     */\r\n    @serializeAsTexture(\"bumpTexture\")\r\n    private _bumpTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture: BaseTexture;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serializeAsColor3()\r\n    public specularColor = new Color3(0, 0, 0);\r\n\r\n    @serialize()\r\n    public specularPower = 64;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    /**\r\n     * Defines the wind force.\r\n     */\r\n    @serialize()\r\n    public windForce: number = 6;\r\n    /**\r\n     * Defines the direction of the wind in the plane (X, Z).\r\n     */\r\n    @serializeAsVector2()\r\n    public windDirection: Vector2 = new Vector2(0, 1);\r\n    /**\r\n     * Defines the height of the waves.\r\n     */\r\n    @serialize()\r\n    public waveHeight: number = 0.4;\r\n    /**\r\n     * Defines the bump height related to the bump map.\r\n     */\r\n    @serialize()\r\n    public bumpHeight: number = 0.4;\r\n    /**\r\n     * Defines wether or not: to add a smaller moving bump to less steady waves.\r\n     */\r\n    @serialize(\"bumpSuperimpose\")\r\n    private _bumpSuperimpose = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public bumpSuperimpose: boolean;\r\n\r\n    /**\r\n     * Defines wether or not color refraction and reflection differently with .waterColor2 and .colorBlendFactor2. Non-linear (physically correct) fresnel.\r\n     */\r\n    @serialize(\"fresnelSeparate\")\r\n    private _fresnelSeparate = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public fresnelSeparate: boolean;\r\n\r\n    /**\r\n     * Defines wether or not bump Wwves modify the reflection.\r\n     */\r\n    @serialize(\"bumpAffectsReflection\")\r\n    private _bumpAffectsReflection = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public bumpAffectsReflection: boolean;\r\n\r\n    /**\r\n     * Defines the water color blended with the refraction (near).\r\n     */\r\n    @serializeAsColor3()\r\n    public waterColor: Color3 = new Color3(0.1, 0.1, 0.6);\r\n    /**\r\n     * Defines the blend factor related to the water color.\r\n     */\r\n    @serialize()\r\n    public colorBlendFactor: number = 0.2;\r\n    /**\r\n     * Defines the water color blended with the reflection (far).\r\n     */\r\n    @serializeAsColor3()\r\n    public waterColor2: Color3 = new Color3(0.1, 0.1, 0.6);\r\n    /**\r\n     * Defines the blend factor related to the water color (reflection, far).\r\n     */\r\n    @serialize()\r\n    public colorBlendFactor2: number = 0.2;\r\n    /**\r\n     * Defines the maximum length of a wave.\r\n     */\r\n    @serialize()\r\n    public waveLength: number = 0.1;\r\n\r\n    /**\r\n     * Defines the waves speed.\r\n     */\r\n    @serialize()\r\n    public waveSpeed: number = 1.0;\r\n\r\n    /**\r\n     * Defines the number of times waves are repeated. This is typically used to adjust waves count according to the ground's size where the material is applied on.\r\n     */\r\n    @serialize()\r\n    public waveCount: number = 20;\r\n    /**\r\n     * Sets or gets whether or not automatic clipping should be enabled or not. Setting to true will save performances and\r\n     * will avoid calculating useless pixels in the pixel shader of the water material.\r\n     */\r\n    @serialize()\r\n    public disableClipPlane: boolean = false;\r\n\r\n    /**\r\n     * Defines whether or not to use world coordinates for wave deformations.\r\n     * The default value is false, meaning that the deformation is applied in object (local) space.\r\n     * You will probably need to set it to true if you are using instances or thin instances for your water objects.\r\n     */\r\n    @serialize(\"useWorldCoordinatesForWaveDeformation\")\r\n    private _useWorldCoordinatesForWaveDeformation = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useWorldCoordinatesForWaveDeformation: boolean;\r\n\r\n    protected _renderTargets = new SmartArray<RenderTargetTexture>(16);\r\n\r\n    /*\r\n     * Private members\r\n     */\r\n    private _mesh: Nullable<AbstractMesh> = null;\r\n\r\n    private _refractionRTT: Nullable<RenderTargetTexture>;\r\n    private _reflectionRTT: Nullable<RenderTargetTexture>;\r\n\r\n    private _reflectionTransform: Matrix = Matrix.Zero();\r\n    private _lastTime: number = 0;\r\n    private _lastDeltaTime: number = 0;\r\n\r\n    private _waitingRenderList: Nullable<string[]>;\r\n\r\n    private _imageProcessingConfiguration: Nullable<ImageProcessingConfiguration>;\r\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>>;\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public override get hasRenderTargetTextures(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     * @param name\r\n     * @param scene\r\n     * @param renderTargetSize\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene?: Scene,\r\n        public renderTargetSize: Vector2 = new Vector2(512, 512)\r\n    ) {\r\n        super(name, scene);\r\n\r\n        this._createRenderTargets(this.getScene(), renderTargetSize);\r\n\r\n        // Create render targets\r\n        this.getRenderTargetTextures = (): SmartArray<RenderTargetTexture> => {\r\n            this._renderTargets.reset();\r\n            this._renderTargets.push(<RenderTargetTexture>this._reflectionRTT);\r\n            this._renderTargets.push(<RenderTargetTexture>this._refractionRTT);\r\n\r\n            return this._renderTargets;\r\n        };\r\n\r\n        this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n                this._markAllSubMeshesAsImageProcessingDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    // Get / Set\r\n    public get refractionTexture(): Nullable<RenderTargetTexture> {\r\n        return this._refractionRTT;\r\n    }\r\n\r\n    public get reflectionTexture(): Nullable<RenderTargetTexture> {\r\n        return this._reflectionRTT;\r\n    }\r\n\r\n    // Methods\r\n    public addToRenderList(node: any): void {\r\n        if (this._refractionRTT && this._refractionRTT.renderList) {\r\n            this._refractionRTT.renderList.push(node);\r\n        }\r\n\r\n        if (this._reflectionRTT && this._reflectionRTT.renderList) {\r\n            this._reflectionRTT.renderList.push(node);\r\n        }\r\n    }\r\n\r\n    public removeFromRenderList(node: any): void {\r\n        if (this._refractionRTT && this._refractionRTT.renderList) {\r\n            const idx = this._refractionRTT.renderList.indexOf(node);\r\n            if (idx !== -1) {\r\n                this._refractionRTT.renderList.splice(idx, 1);\r\n            }\r\n        }\r\n\r\n        if (this._reflectionRTT && this._reflectionRTT.renderList) {\r\n            const idx = this._reflectionRTT.renderList.indexOf(node);\r\n            if (idx !== -1) {\r\n                this._reflectionRTT.renderList.splice(idx, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    public enableRenderTargets(enable: boolean): void {\r\n        const refreshRate = enable ? 1 : 0;\r\n\r\n        if (this._refractionRTT) {\r\n            this._refractionRTT.refreshRate = refreshRate;\r\n        }\r\n\r\n        if (this._reflectionRTT) {\r\n            this._reflectionRTT.refreshRate = refreshRate;\r\n        }\r\n    }\r\n\r\n    public getRenderList(): Nullable<AbstractMesh[]> {\r\n        return this._refractionRTT ? this._refractionRTT.renderList : [];\r\n    }\r\n\r\n    public get renderTargetsEnabled(): boolean {\r\n        return !(this._refractionRTT && this._refractionRTT.refreshRate === 0);\r\n    }\r\n\r\n    public override needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public override needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public override getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new WaterMaterialDefines();\r\n        }\r\n\r\n        const defines = <WaterMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this.bumpTexture && MaterialFlags.BumpTextureEnabled) {\r\n                    if (!this.bumpTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.BUMP = true;\r\n                    }\r\n                }\r\n\r\n                if (MaterialFlags.ReflectionTextureEnabled) {\r\n                    defines.REFLECTION = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines);\r\n\r\n        if (defines._areMiscDirty) {\r\n            defines.FRESNELSEPARATE = this._fresnelSeparate;\r\n            defines.BUMPSUPERIMPOSE = this._bumpSuperimpose;\r\n            defines.BUMPAFFECTSREFLECTION = this._bumpAffectsReflection;\r\n            defines.USE_WORLD_COORDINATES = this._useWorldCoordinatesForWaveDeformation;\r\n        }\r\n\r\n        // Lights\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Image processing\r\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\r\n            if (!this._imageProcessingConfiguration.isReady()) {\r\n                return false;\r\n            }\r\n\r\n            this._imageProcessingConfiguration.prepareDefines(defines);\r\n\r\n            defines.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace;\r\n            defines.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;\r\n        }\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Configure this\r\n        this._mesh = mesh;\r\n\r\n        if (this._waitingRenderList) {\r\n            for (let i = 0; i < this._waitingRenderList.length; i++) {\r\n                this.addToRenderList(scene.getNodeById(this._waitingRenderList[i]));\r\n            }\r\n\r\n            this._waitingRenderList = null;\r\n        }\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            if (defines.LOGARITHMICDEPTH) {\r\n                fallbacks.addFallback(0, \"LOGARITHMICDEPTH\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"water\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vSpecularColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vNormalInfos\",\r\n                \"mBones\",\r\n                \"normalMatrix\",\r\n                \"logarithmicDepthConstant\",\r\n\r\n                // Water\r\n                \"reflectionViewProjection\",\r\n                \"windDirection\",\r\n                \"waveLength\",\r\n                \"time\",\r\n                \"windForce\",\r\n                \"cameraPosition\",\r\n                \"bumpHeight\",\r\n                \"waveHeight\",\r\n                \"waterColor\",\r\n                \"waterColor2\",\r\n                \"colorBlendFactor\",\r\n                \"colorBlendFactor2\",\r\n                \"waveSpeed\",\r\n                \"waveCount\",\r\n            ];\r\n            const samplers = [\r\n                \"normalSampler\",\r\n                // Water\r\n                \"refractionSampler\",\r\n                \"reflectionSampler\",\r\n            ];\r\n            const uniformBuffers: string[] = [];\r\n\r\n            if (ImageProcessingConfiguration) {\r\n                ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\r\n                ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\r\n            }\r\n\r\n            AddClipPlaneUniforms(uniforms);\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <WaterMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect || !this._mesh) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this.bumpTexture && MaterialFlags.BumpTextureEnabled) {\r\n                this._activeEffect.setTexture(\"normalSampler\", this.bumpTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vNormalInfos\", this.bumpTexture.coordinatesIndex, this.bumpTexture.level);\r\n                this._activeEffect.setMatrix(\"normalMatrix\", this.bumpTexture.getTextureMatrix());\r\n            }\r\n            // Clip plane\r\n            BindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            this._activeEffect.setColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        // Log. depth\r\n        BindLogDepth(defines, this._activeEffect, scene);\r\n\r\n        // Water\r\n        if (MaterialFlags.ReflectionTextureEnabled) {\r\n            this._activeEffect.setTexture(\"refractionSampler\", this._refractionRTT);\r\n            this._activeEffect.setTexture(\"reflectionSampler\", this._reflectionRTT);\r\n        }\r\n\r\n        const wrvp = this._reflectionTransform.multiply(scene.getProjectionMatrix());\r\n\r\n        // Add delta time. Prevent adding delta time if it hasn't changed.\r\n        const deltaTime = scene.getEngine().getDeltaTime();\r\n        if (deltaTime !== this._lastDeltaTime) {\r\n            this._lastDeltaTime = deltaTime;\r\n            this._lastTime += this._lastDeltaTime;\r\n        }\r\n\r\n        this._activeEffect.setMatrix(\"reflectionViewProjection\", wrvp);\r\n        this._activeEffect.setVector2(\"windDirection\", this.windDirection);\r\n        this._activeEffect.setFloat(\"waveLength\", this.waveLength);\r\n        this._activeEffect.setFloat(\"time\", this._lastTime / 100000);\r\n        this._activeEffect.setFloat(\"windForce\", this.windForce);\r\n        this._activeEffect.setFloat(\"waveHeight\", this.waveHeight);\r\n        this._activeEffect.setFloat(\"bumpHeight\", this.bumpHeight);\r\n        this._activeEffect.setColor4(\"waterColor\", this.waterColor, 1.0);\r\n        this._activeEffect.setFloat(\"colorBlendFactor\", this.colorBlendFactor);\r\n        this._activeEffect.setColor4(\"waterColor2\", this.waterColor2, 1.0);\r\n        this._activeEffect.setFloat(\"colorBlendFactor2\", this.colorBlendFactor2);\r\n        this._activeEffect.setFloat(\"waveSpeed\", this.waveSpeed);\r\n        this._activeEffect.setFloat(\"waveCount\", this.waveCount);\r\n\r\n        // image processing\r\n        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\r\n            this._imageProcessingConfiguration.bind(this._activeEffect);\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    private _createRenderTargets(scene: Scene, renderTargetSize: Vector2): void {\r\n        // Render targets\r\n        this._refractionRTT = new RenderTargetTexture(name + \"_refraction\", { width: renderTargetSize.x, height: renderTargetSize.y }, scene, false, true);\r\n        this._refractionRTT.wrapU = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n        this._refractionRTT.wrapV = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n        this._refractionRTT.ignoreCameraViewport = true;\r\n\r\n        let boundingBoxRendererEnabled = false;\r\n        this._refractionRTT.onBeforeRenderObservable.add(() => {\r\n            boundingBoxRendererEnabled = scene.getBoundingBoxRenderer().enabled;\r\n            scene.getBoundingBoxRenderer().enabled = false;\r\n        });\r\n        this._refractionRTT.onAfterRenderObservable.add(() => {\r\n            scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled;\r\n        });\r\n\r\n        this._reflectionRTT = new RenderTargetTexture(name + \"_reflection\", { width: renderTargetSize.x, height: renderTargetSize.y }, scene, false, true);\r\n        this._reflectionRTT.wrapU = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n        this._reflectionRTT.wrapV = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n        this._reflectionRTT.ignoreCameraViewport = true;\r\n\r\n        let isVisible: boolean;\r\n        let clipPlane: Nullable<Plane> = null;\r\n        let savedViewMatrix: Matrix;\r\n        const mirrorMatrix = Matrix.Zero();\r\n\r\n        this._refractionRTT.onBeforeRender = () => {\r\n            if (this._mesh) {\r\n                isVisible = this._mesh.isVisible;\r\n                this._mesh.isVisible = false;\r\n            }\r\n\r\n            // Clip plane\r\n            if (!this.disableClipPlane) {\r\n                clipPlane = scene.clipPlane;\r\n\r\n                const positiony = this._mesh ? this._mesh.absolutePosition.y : 0.0;\r\n                scene.clipPlane = Plane.FromPositionAndNormal(new Vector3(0, positiony + 0.05, 0), new Vector3(0, 1, 0));\r\n            }\r\n        };\r\n\r\n        this._refractionRTT.onAfterRender = () => {\r\n            if (this._mesh) {\r\n                this._mesh.isVisible = isVisible;\r\n            }\r\n\r\n            // Clip plane\r\n            if (!this.disableClipPlane) {\r\n                scene.clipPlane = clipPlane;\r\n            }\r\n        };\r\n\r\n        this._reflectionRTT.onBeforeRender = () => {\r\n            if (this._mesh) {\r\n                isVisible = this._mesh.isVisible;\r\n                this._mesh.isVisible = false;\r\n            }\r\n\r\n            // Clip plane\r\n            if (!this.disableClipPlane) {\r\n                clipPlane = scene.clipPlane;\r\n\r\n                const positiony = this._mesh ? this._mesh.absolutePosition.y : 0.0;\r\n                scene.clipPlane = Plane.FromPositionAndNormal(new Vector3(0, positiony - 0.05, 0), new Vector3(0, -1, 0));\r\n\r\n                Matrix.ReflectionToRef(scene.clipPlane, mirrorMatrix);\r\n            }\r\n\r\n            // Transform\r\n            savedViewMatrix = scene.getViewMatrix();\r\n\r\n            mirrorMatrix.multiplyToRef(savedViewMatrix, this._reflectionTransform);\r\n            scene.setTransformMatrix(this._reflectionTransform, scene.getProjectionMatrix());\r\n            scene._mirroredCameraPosition = Vector3.TransformCoordinates((<Camera>scene.activeCamera).position, mirrorMatrix);\r\n        };\r\n\r\n        this._reflectionRTT.onAfterRender = () => {\r\n            if (this._mesh) {\r\n                this._mesh.isVisible = isVisible;\r\n            }\r\n\r\n            // Clip plane\r\n            scene.clipPlane = clipPlane;\r\n\r\n            // Transform\r\n            scene.setTransformMatrix(savedViewMatrix, scene.getProjectionMatrix());\r\n            scene._mirroredCameraPosition = null;\r\n        };\r\n    }\r\n\r\n    public override getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this.bumpTexture && this.bumpTexture.animations && this.bumpTexture.animations.length > 0) {\r\n            results.push(this.bumpTexture);\r\n        }\r\n        if (this._reflectionRTT && this._reflectionRTT.animations && this._reflectionRTT.animations.length > 0) {\r\n            results.push(this._reflectionRTT);\r\n        }\r\n        if (this._refractionRTT && this._refractionRTT.animations && this._refractionRTT.animations.length > 0) {\r\n            results.push(this._refractionRTT);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public override getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._bumpTexture) {\r\n            activeTextures.push(this._bumpTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.bumpTexture) {\r\n            this.bumpTexture.dispose();\r\n        }\r\n\r\n        let index = this.getScene().customRenderTargets.indexOf(<RenderTargetTexture>this._refractionRTT);\r\n        if (index != -1) {\r\n            this.getScene().customRenderTargets.splice(index, 1);\r\n        }\r\n        index = -1;\r\n        index = this.getScene().customRenderTargets.indexOf(<RenderTargetTexture>this._reflectionRTT);\r\n        if (index != -1) {\r\n            this.getScene().customRenderTargets.splice(index, 1);\r\n        }\r\n\r\n        if (this._reflectionRTT) {\r\n            this._reflectionRTT.dispose();\r\n        }\r\n        if (this._refractionRTT) {\r\n            this._refractionRTT.dispose();\r\n        }\r\n\r\n        // Remove image-processing observer\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public override clone(name: string): WaterMaterial {\r\n        return SerializationHelper.Clone(() => new WaterMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.WaterMaterial\";\r\n\r\n        serializationObject.renderList = [];\r\n        if (this._refractionRTT && this._refractionRTT.renderList) {\r\n            for (let i = 0; i < this._refractionRTT.renderList.length; i++) {\r\n                serializationObject.renderList.push(this._refractionRTT.renderList[i].id);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"WaterMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): WaterMaterial {\r\n        const mat = SerializationHelper.Parse(() => new WaterMaterial(source.name, scene), source, scene, rootUrl);\r\n        mat._waitingRenderList = source.renderList;\r\n\r\n        return mat;\r\n    }\r\n\r\n    public static CreateDefaultMesh(name: string, scene: Scene): Mesh {\r\n        const mesh = CreateGround(name, { width: 512, height: 512, subdivisions: 32, updatable: false }, scene);\r\n        return mesh;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.WaterMaterial\", WaterMaterial);\r\n","/* eslint-disable @typescript-eslint/no-restricted-imports */\r\nimport * as MatLib from \"materials/index\";\r\n\r\n/**\r\n * Legacy support, defining window.BABYLON.GridMaterial... (global variable).\r\n *\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nconst globalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof globalObject !== \"undefined\") {\r\n    (<any>globalObject).BABYLON = (<any>globalObject).BABYLON || {};\r\n    for (const mat in MatLib) {\r\n        (<any>globalObject).BABYLON[mat] = (<any>MatLib)[mat];\r\n    }\r\n}\r\n\r\nexport * from \"materials/index\";\r\n","import * as materials from \"@lts/materials/legacy/legacy\";\r\nexport { materials };\r\nexport default materials;\r\n"],"names":["root","factory","exports","module","require","define","amd","self","global","this","__WEBPACK_EXTERNAL_MODULE__597__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","Function","e","window","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","extendStatics","b","setPrototypeOf","__proto__","Array","p","__extends","TypeError","String","__","constructor","create","__decorate","decorators","target","desc","c","arguments","length","getOwnPropertyDescriptor","Reflect","decorate","i","SuppressedError","ShaderStore","ShadersStore","DIFFUSE","CLIPPLANE","CLIPPLANE2","CLIPPLANE3","CLIPPLANE4","CLIPPLANE5","CLIPPLANE6","ALPHATEST","POINTSIZE","FOG","NORMAL","UV1","UV2","VERTEXCOLOR","VERTEXALPHA","NUM_BONE_INFLUENCERS","BonesPerMesh","INSTANCES","INSTANCESCOLOR","NDOTL","CUSTOMUSERLIGHTING","CELLBASIC","DEPTHPREPASS","IMAGEPROCESSINGPOSTPROCESS","SKIPFINALCOLORCLAMP","LOGARITHMICDEPTH","AREALIGHTSUPPORTED","AREALIGHTNOROUGHTNESS","rebuild","MaterialDefines","name","scene","diffuseColor","Color3","_computeHighLevel","_disableLighting","_maxSimultaneousLights","needAlphaBlending","alpha","needAlphaTesting","getAlphaTestTexture","isReadyForSubMesh","mesh","subMesh","useInstances","drawWrapper","_drawWrapper","isFrozen","effect","_wasPreviouslyReady","_wasPreviouslyUsingInstances","materialDefines","CellMaterialDefines","defines","getScene","_isReadyForSubMesh","engine","getEngine","_areTexturesDirty","_needUVs","texturesEnabled","_diffuseTexture","MaterialFlags","DiffuseTextureEnabled","isReady","computeHighLevel","PrepareDefinesForMisc","_useLogarithmicDepth","pointsCloud","fogEnabled","needAlphaTestingForMesh","_needNormals","PrepareDefinesForLights","PrepareDefinesForFrameBoundValues","PrepareDefinesForAttributes","isDirty","markAsProcessed","resetCachedMaterial","fallbacks","EffectFallbacks","addFallback","HandleFallbacksForShadows","maxSimultaneousLights","addCPUSkinningFallback","imageProcessingConfiguration","applyByPostProcess","attribs","VertexBuffer","PositionKind","push","NormalKind","UVKind","UV2Kind","ColorKind","PrepareAttributesForBones","PrepareAttributesForInstances","join","toString","uniforms","samplers","uniformBuffers","AddClipPlaneUniforms","PrepareUniformsAndSamplersList","uniformsNames","uniformBuffersNames","setEffect","createEffect","attributes","onCompiled","onError","indexParameters","_materialContext","index","lightSources","_isReady","_renderId","getRenderId","bindForSubMesh","world","_activeEffect","bindOnlyWorldMatrix","setMatrix","getTransformMatrix","BindBonesParameters","_mustRebind","setTexture","setFloat2","coordinatesIndex","level","getTextureMatrix","BindClipPlane","setFloat","pointSize","BindLogDepth","bindEyePosition","setColor4","visibility","lightsEnabled","disableLighting","BindLights","applyFog","fogMode","Scene","FOGMODE_NONE","getViewMatrix","BindFogParameters","_afterBind","getAnimatables","results","animations","getActiveTextures","activeTextures","hasTexture","texture","dispose","forceDisposeEffect","getClassName","clone","SerializationHelper","Clone","CellMaterial","serialize","serializationObject","customType","Parse","source","rootUrl","serializeAsTexture","expandToProperty","serializeAsColor3","PushMaterial","RegisterClass","CustomParts","ShaderSpecialParts","customShaderNameResolve","Builder","FragmentShader","Effect","VertexShader","CustomMaterial","ShaderIndexer","_createdShaderName","AttachAfterBind","_newUniformInstances","el","ea","split","setVector2","setColor3","setVector3","Color4","setDirectColor4","setVector4","_newSamplerInstances","ReviewUniform","arr","_newUniforms","ind","_customUniform","indexOf","replace","shaderName","_customAttributes","_injectCustomCode","code","shaderType","customCode","_getCustomCode","point","injectedCode","fullPointName","CUSTOM_VERTEX_BEGIN","Vertex_Begin","CUSTOM_VERTEX_DEFINITIONS","Vertex_Definitions","CUSTOM_VERTEX_MAIN_BEGIN","Vertex_MainBegin","CUSTOM_VERTEX_UPDATE_POSITION","Vertex_Before_PositionUpdated","CUSTOM_VERTEX_UPDATE_NORMAL","Vertex_Before_NormalUpdated","CUSTOM_VERTEX_MAIN_END","Vertex_MainEnd","CUSTOM_VERTEX_UPDATE_WORLDPOS","Vertex_After_WorldPosComputed","CUSTOM_FRAGMENT_BEGIN","Fragment_Begin","CUSTOM_FRAGMENT_DEFINITIONS","Fragment_Definitions","CUSTOM_FRAGMENT_MAIN_BEGIN","Fragment_MainBegin","CUSTOM_FRAGMENT_UPDATE_DIFFUSE","Fragment_Custom_Diffuse","CUSTOM_FRAGMENT_UPDATE_ALPHA","Fragment_Custom_Alpha","CUSTOM_FRAGMENT_BEFORE_LIGHTS","Fragment_Before_Lights","CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR","Fragment_Before_FragColor","CUSTOM_FRAGMENT_MAIN_END","Fragment_MainEnd","CUSTOM_FRAGMENT_BEFORE_FOG","Fragment_Before_Fog","AddUniform","kind","param","AddAttribute","shaderPart","StandardMaterial","ShaderAlebdoParts","ShaderAlbedoParts","IncludesShadersStore","PBRCustomMaterial","options","processFinalCode","type","sci","ShaderCodeInliner","inlineToken","processCode","CUSTOM_FRAGMENT_UPDATE_ALBEDO","Fragment_Custom_Albedo","CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS","Fragment_Custom_MetallicRoughness","CUSTOM_FRAGMENT_UPDATE_MICROSURFACE","Fragment_Custom_MicroSurface","CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION","Fragment_Before_FinalColorComposition","PBRMaterial","speed","_scaledDiffuse","_lastTime","FireMaterialDefines","_opacityTexture","_areMiscDirty","forcePointsCloud","transformFeedbackVaryings","_distortionTexture","getDeltaTime","FireMaterial","asArray","material","FromArray","id","Tags","AddTagsTo","tags","backFaceCulling","wireframe","Texture","HEIGHTMAP","HIGHLEVEL","furLength","furAngle","furColor","furOffset","furSpacing","furGravity","Vector3","furSpeed","furDensity","furOcclusion","highLevelFur","_furTime","furTime","updateFur","_meshes","offsetFur","diffuseTexture","furTexture","FurMaterialDefines","heightTexture","getCaps","maxVertexTextureImageUnits","markAsUnprocessed","_heightTexture","mat","FurMaterial","sourceMeshName","quality","executeWhenReady","sourceMesh","getMeshByName","GenerateTexture","FurifyMesh","DynamicTexture","context","getContext","fillStyle","Math","floor","random","fillRect","getSize","width","height","update","wrapU","WRAP_ADDRESSMODE","wrapV","meshes","materials","pop","EnableFor","offsetMesh","skeleton","position","Zero","parent","serializeAsVector3","EMISSIVE","topColor","topColorAlpha","bottomColor","bottomColorAlpha","offset","scale","smoothness","GradientMaterialDefines","GradientMaterial","OPACITY","ANTIALIAS","TRANSPARENT","PREMULTIPLYALPHA","MAX_LINE","THIN_INSTANCES","mainColor","Black","lineColor","Teal","gridRatio","gridOffset","majorUnitFrequency","minorUnitVisibility","opacity","antialias","preMultiplyAlpha","useMaxLine","_gridControl","Vector4","needAlphaBlendingForMesh","GridMaterialDefines","OpacityTextureEnabled","THIN_INSTANCE","bindView","bindViewProjection","x","y","round","z","w","GridMaterial","LIGHT0","LIGHT1","LIGHT2","LIGHT3","SPOTLIGHT0","SPOTLIGHT1","SPOTLIGHT2","SPOTLIGHT3","HEMILIGHT0","HEMILIGHT1","HEMILIGHT2","HEMILIGHT3","DIRLIGHT0","DIRLIGHT1","DIRLIGHT2","DIRLIGHT3","POINTLIGHT0","POINTLIGHT1","POINTLIGHT2","POINTLIGHT3","SHADOW0","SHADOW1","SHADOW2","SHADOW3","SHADOWS","SHADOWESM0","SHADOWESM1","SHADOWESM2","SHADOWESM3","SHADOWPOISSON0","SHADOWPOISSON1","SHADOWPOISSON2","SHADOWPOISSON3","SHADOWPCF0","SHADOWPCF1","SHADOWPCF2","SHADOWPCF3","SHADOWPCSS0","SHADOWPCSS1","SHADOWPCSS2","SHADOWPCSS3","UNLIT","movingSpeed","lowFrequencySpeed","fogDensity","_unlit","LavaMaterialDefines","noiseTexture","fogColor","LavaMaterial","SPECULARTERM","MIXMAP2","specularColor","specularPower","MixMaterialDefines","_mixTexture1","_diffuseTexture1","_diffuseTexture2","_diffuseTexture3","_diffuseTexture4","_mixTexture2","_diffuseTexture5","_diffuseTexture6","_diffuseTexture7","_diffuseTexture8","uScale","vScale","MixMaterial","LIGHTING","NormalMaterialDefines","getRenderingMesh","hasThinInstances","NormalMaterial","_needAlphaBlending","shadowColor","_activeLight","light","_getFirstShadowLightForMesh","shadowEnabled","ShadowOnlyMaterialDefines","lightPosition","splice","shadowGenerator","getShadowGenerator","csg","autoCalcDepthBounds","ShadowOnlyMaterial","SimpleMaterialDefines","SimpleMaterial","DITHER","luminance","turbidity","rayleigh","mieCoefficient","mieDirectionalG","distance","inclination","azimuth","sunPosition","useSunPosition","cameraOffset","up","Up","dithering","_cameraPosition","_skyOrientation","Quaternion","SkyMaterialDefines","markAsMiscDirty","camera","activeCamera","cameraWorldMatrix","getWorldMatrix","m","theta","PI","phi","cos","sin","FromUnitVectorsToRef","UpReadOnly","rotateByQuaternionToRef","SkyMaterial","BUMP","TerrainMaterialDefines","mixTexture","diffuseTexture1","diffuseTexture2","diffuseTexture3","bumpTexture1","bumpTexture2","bumpTexture3","BumpTextureEnabled","_mixTexture","standardDerivatives","_bumpTexture1","_bumpTexture2","_bumpTexture3","TerrainMaterial","DIFFUSEX","DIFFUSEY","DIFFUSEZ","BUMPX","BUMPY","BUMPZ","NONUNIFORMSCALING","tileSize","TriPlanarMaterialDefines","textures","diffuseTextureX","diffuseTextureY","diffuseTextureZ","textureDefines","normalTextureX","normalTextureY","normalTextureZ","_diffuseTextureX","_diffuseTextureY","_diffuseTextureZ","_normalTextureX","_normalTextureY","_normalTextureZ","TriPlanarMaterial","REFLECTION","USE_REVERSE_DEPTHBUFFER","FRESNELSEPARATE","BUMPSUPERIMPOSE","BUMPAFFECTSREFLECTION","USE_WORLD_COORDINATES","IMAGEPROCESSING","VIGNETTE","VIGNETTEBLENDMODEMULTIPLY","VIGNETTEBLENDMODEOPAQUE","TONEMAPPING","CONTRAST","EXPOSURE","COLORCURVES","COLORGRADING","COLORGRADING3D","SAMPLER3DGREENDEPTH","SAMPLER3DBGRMAP","renderTargetSize","Vector2","windForce","windDirection","waveHeight","bumpHeight","_bumpSuperimpose","_fresnelSeparate","_bumpAffectsReflection","waterColor","colorBlendFactor","waterColor2","colorBlendFactor2","waveLength","waveSpeed","waveCount","disableClipPlane","_useWorldCoordinatesForWaveDeformation","_renderTargets","SmartArray","_mesh","_reflectionTransform","Matrix","_lastDeltaTime","_createRenderTargets","getRenderTargetTextures","reset","_reflectionRTT","_refractionRTT","_imageProcessingConfiguration","_imageProcessingObserver","onUpdateParameters","add","_markAllSubMeshesAsImageProcessingDirty","addToRenderList","node","renderList","removeFromRenderList","idx","enableRenderTargets","enable","refreshRate","getRenderList","WaterMaterialDefines","bumpTexture","ReflectionTextureEnabled","_areImageProcessingDirty","prepareDefines","IS_REFLECTION_LINEAR","reflectionTexture","gammaSpace","IS_REFRACTION_LINEAR","refractionTexture","_waitingRenderList","getNodeById","ImageProcessingConfiguration","PrepareUniforms","PrepareSamplers","wrvp","multiply","getProjectionMatrix","deltaTime","bind","RenderTargetTexture","Constants","TEXTURE_MIRROR_ADDRESSMODE","ignoreCameraViewport","isVisible","boundingBoxRendererEnabled","onBeforeRenderObservable","getBoundingBoxRenderer","enabled","onAfterRenderObservable","savedViewMatrix","clipPlane","mirrorMatrix","onBeforeRender","positiony","absolutePosition","Plane","FromPositionAndNormal","onAfterRender","ReflectionToRef","multiplyToRef","setTransformMatrix","_mirroredCameraPosition","TransformCoordinates","_bumpTexture","customRenderTargets","remove","WaterMaterial","CreateDefaultMesh","CreateGround","subdivisions","updatable","serializeAsVector2","globalObject","BABYLON"],"sourceRoot":""}